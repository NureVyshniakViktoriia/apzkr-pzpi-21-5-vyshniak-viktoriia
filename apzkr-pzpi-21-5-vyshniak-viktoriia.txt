Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контролю за місцезнаходженням і здоров’ям тварин та зручності відвідування закладів пет-френдлі

Студент гр. ПЗПІ-21-5
________________________Вишняк В.Є.
(підпис)
Керівник роботи
________________ ст.викл. Сокорчук І.П.
(підпис)

Роботу захищено «____»________2024 р.
з оцінкою _________________________
Комісія
________________доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
________________ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної  інженерії
Спеціальність 121 – Інженерія програмного забезпечення
Курс	3	Семестр	6
Навчальна дисципліна Архітектура програмного забезпечення

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

________________Вишняк Вікторії Євгенівні______________________

1. Тема проекту: «Програмна система для контролю за місцезнаходженням і здоров’ям тварин та зручності відвідування закладів пет-френдлі»
2. Термін узгодження завдання курсової роботи «18» березня 2024 р.
3. Термін здачі студентом закінченої роботи «15» червня 2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити: реєстрацію та авторизацію власників закладів пет-френдлі, власників домашніх улюбленців, адміністраторів та системних адміністраторів системи, додавання та оновлення інформації про установи пет-френдлі та їхні послуги, сортування та фільтрація по установах пет-френдлі, додавання, редагування профілів тварин та записів у щоденнику тварини, конфігурація розумних пристроїв для відстеження температури тварини та її поточного місцезнаходження, збір та виведення інформації для адміністратора системи щодо активних користувачів та закладів пет-френдлі, обчислення зваженого рейтингу установи, збір та виведення статистики з показників здоров’я домашнього улюбленця, збір інформації про поточне місцезнаходження тварини, надсилання інформації про тварину адміністратору при скануванні мітки на ошийнику тварини, управління бекапами. Використовувати ОС Windows 11, СУБД Microsoft SQL Server 2019, середовища розробки Microsoft Visual Studio 2022, Android Studio, редактор коду Visual Studio Code, мови програмування С#, TypeScript, Kotlin, Javascript, C++, PlatformIO, фреймворк Angular 17
5. Зміст пояснювальної записки (перелік питань, що належить розробити) 
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки 
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) схема моделі бази даних, діаграма прецедентів, діаграма розгортання, діаграма компонентів, діаграма діяльності, інтерфейс застосунку


КАЛЕНДАРНИЙ ПЛАН


№
Назва етапів курсової роботи
Термін виконання
етапів роботи
Примітка
1
Функціональна специфікація програмного проекту
20.03.2024
виконано
2
Проектування програмного проекту
06.04.2024
виконано
3
Кодування програмного проекту
01.06.2024
виконано
4
Оформлення пояснювальної
записки
05.06.2024
виконано
5
Захист курсової роботи
15.06.2024
виконано

     Дата видачі теми проекту «18» березня 2024 р.

     Керівник
__________ст. викл. Сокорчук І.П.
(підпис)

     Завдання прийняла до виконання
     ст. гр. ПЗПІ-21-5
___________ Вишняк В. Є. (підпис)


РЕФЕРАТ
     
     
     Пояснювальна записка до курсової роботи: 97 с., 38 рис., 7 додатків, 6 джерел.
     C#, .NET, SQL, ДОМАШНІ УЛЮБЛЕНЦІ, ІНФОРМАЦІЙНА СИСТЕМА, КОНТРОЛЬ ЗА МІСЦЕЗНАХОДЖЕННЯМ ТВАРИН, КОНТРОЛЬ ЗДОРОВ’Я ТВАРИН, ПЕТ-ФРЕНДЛІ, ЧИСТА АРХІТЕКТУРА.
     Об’єктом дослідження є покращення процесу догляду за домашніми улюбленцями, поліпшення сервісу та створення умов для безпечного середовища в закладах для відвідування з тваринами.
     Можна виділити наступні методи дослідження: аналіз, концептуальне, ER-та UML-моделювання предметної області, розробка та проектування реляційної бази даних.
     Метою даної роботи є реалізація складної інформаційної системи для контролю за місцезнаходженням і здоров’ям тварин та зручності відвідування закладів пет-френдлі. Продукт включатиме серверну, веб-частину, IoT- та мобільний застосунки.
     У ході проектування та написання програми були використані наступні технології: ASP.NET Core Web API та C# для серверної частини, СУБД MS SQL Server 2019, ORM Entity Framework Core 7 для доступу до даних. IoT-частина реалізована на C++ з використанням PlatformIO; клієнтська частина – на Angular 17, Typescript, HTML і SCSS; мобільний застосунок – на Kotlin та Android Studio.
     У результаті курсового проектування створено складну інформаційну систему, що спрямована на посилення безпеки та підвищення рівня сервісу у відповідних установах пет-френдлі шляхом отримання інформації про тварин-відвідувачів після сканування мітки на ошийнику улюбленця, наданні можливості якісного догляду за твариною, контролю за її здоров’ям та місцеперебуванням за допомогою спеціальних міток, створюючи надійне та ефективне середовище для власників тварин та персоналу пет-френдлі закладів.

ЗМІСТ


ВСТУП………………..................................................................................................8
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ.......................................................................10
   1.1 Загальний огляд предметної області………….……………………….........10
   1.2 Аналіз наявних аналогів…………………………………………….............11
2 ПОСТАНОВКА ЗАДАЧІ...…...…………………………………………...……...13
   2.1 Постановка бачення програмної системи…..………………………….......13
   2.2 Основний функціонал системи…....…………………………………..........14
   2.3 Рамки первинного випуску……………...…………………………..............15
   2.4 Рамки наступних випусків……………...…………………………...............18
   2.5 Робоче середовище та вимоги до системи…………….……………...........19
3 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ….....……………………….......20
   3.1 Загальний огляд архітектури системи.......….………………………….......20
   3.2 Проектування серверної частини системи...….…………………………....20
   3.3 Проектування IoT-частини системи...………….……………...…………...21
   3.4 Проектування клієнтської частини системи…...……………...……...........23
   3.5 Проектування мобільного застосунку….…....………………...……...........25
4 СТРУКТУРА БАЗИ ДАНИХ………………………..……………………............26
5 КОДУВАННЯ ПРОГРАМНОЇ СИСТЕМИ….....……………………..................28
   5.1 Кодування серверної частини системи….….……………………………...28
   5.2 Кодування IoT-частини системи...………….………………...……….........29
   5.3 Кодування клієнтської частини системи…...………………...…….............30
   5.4 Кодування мобільного застосунку………....………………...……..............31
6 ОПИС ПРОГРАМНОЇ РЕАЛІЗАЦІЇ………..…...…..……………………...........33
   6.1 Реалізація серверної частини системи….….………………………….........33
   6.2 Реалізація IoT-частини системи...………….…….………………………....33
   6.3 Реалізація клієнтської частини системи…...………………………............36
   6.4 Реалізація мобільного застосунку системи..………….……………............43
ВИСНОВКИ………………………………………...…..……………………..........47
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ..……………...…..……………………..........48
ДОДАТОК А Побудовані діаграми………………………………………………...49
ДОДАТОК Б REST-специфікація…………………………………………………..65
ДОДАТОК В Фрагменти програмного коду серверної частини системи………..72
ДОДАТОК Г Фрагменти програмного коду IoT-частини системи……………….78
ДОДАТОК Д Фрагменти програмного коду клієнтської частини системи……...82
ДОДАТОК Е Фрагменти програмного коду мобільного застосунку……………87
ДОДАТОК Ж Результат перевірки на відсоток плагіату…………………………97


ВСТУП
     
     
     За даними відомого журналу «Forbes» 66% мешканців США є власниками домашніх улюбленців. У свою чергу, загальна кількість власників домашніх тварин по світу складає більше, ніж 50%.
     Разом із поширенням попиту на тварин зростає самосвідомість та відповідальність у їхніх господарів. На жаль, через брак часу в людей та стрес, що завдають регулярні медичні обстеження тваринам, стає складно забезпечити відповідний догляд за домашніми улюбленцями, наслідком чого є висока захворюваність тварин через невчасне виявлення проблем зі здоров’ям. Також тварини часто губляться, а через нестачу відповідних інструментів для відстеження їхнього місцезнаходження вони стають безхатніми або гинуть.
     Крім цього, кожного року спостерігається зростання кількості установ для відвідування з тваринами, і це не тільки медичні заклади, а ще й заклади громадського харчування, зали, салони краси тощо. Через велике скупчення тварин в одному місці та відсутність належного контролю за станом здоров’я тварин-відвідувачів зростає вірогідність спалаху інфекцій як серед тварин, так і серед їхніх власників, що може сприяти негативному користувацькому досвіду та закриттю установ пет-френдлі в подальшому.
     До того ж, у світі спостерігається посилення обмежень та відповідних заходів щодо доступу до особистої інформації та її поширення. Система «PawPoint» дозволить вирішити дану проблему шляхом ідентифікації людини за її домашнім улюбленцем.
     Також далеко не кожен господар хоче витрачати час та підвищувати рівень стресу у домашнього улюбленця під час вимірювання температури, годинами шукати пет-френдлі заклад поруч.
     Рішенням згаданих вище проблем стане програмна система, що дозволить власникам домашніх тварин стежити за їхнім здоров’ям, місцезнаходженням через спеціальні мітки на ошийнику та отримувати інформацію про пет-френдлі установи. Для закладів продукт стане адміністративною панеллю для отримання даних про тварин-відвідувачів та створення ефективного середовища в межах закладу для відвідування з тваринами.
     Темою даної роботи є створення програмної системи для контролю за місцезнаходженням і здоров’ям тварин та зручності відвідування закладів пет-френдлі.
     Метою курсового проектування є створення зручного інтерфейсу для власників тварин та установам пет-френдлі для забезпечення відповідного нагляду за домашніми улюбленцями та створення умов для надання високого рівню сервісу відвідувачам та посилення заходів безпеки в межах установи.
     Крім цього, сервіс ставить на меті спрощення процесу нагляду за твариною, контролюючи її поточне місцеперебування та надаючи актуальну статистику показників температури тіла тварини за обраний проміжок часу. 
     З появою даної програмної системи очікується поліпшення користувацького досвіду серед відвідувачів дружніх до тварин установ, зменшення випадків захворюваності та зникнення тварин.
     Відповідність сучасним стандартам розробки програмного забезпечення та побудова архітектури на засадах чистого коду та чистої архітектури сприятиме масштабованості та гнучкості системи у майбутньому [1] [2].


1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Аналіз предметної області
     
     
     У сучасному світі рух пет-френдлі набирає великої популярності серед любителів та захисників тварин. Люди все більше усвідомлюють важливість догляду за своїми домашніми улюбленцями та дбають про їхнє здоров’я.
     Але навіть найкращий догляд за твариною не виключає випадків її втрати або смерті. Для запобігання цих ризиків власникам тварин необхідно мати доступ до місцеперебування тварини в реальному часі та можливість отримувати актуальну статистику показників здоров’я домашнього улюбленця.
     Разом із появою установ пет-френдлі, як кафе, салони краси, спортивні зали, ветеринарні клініки, збільшується ризик загрози безпеці суспільства через можливу відсутність щеплень від сказу у тварин-відвідувачів відповідних установ. Відсутність щеплень може призвести до поширення захворювань серед інших тварин, а також становити загрозу для здоров’я людей, які перебувають в цьому середовищі. Система контролю за наявністю щеплень зможе забезпечити безпеку усіх відвідувачів: як тварин, так і їх власників, надаючи доступ до закладу тільки з тваринами, що мають усі належні медичні документи. 
     Крім цього, у багатьох країнах Європи посилені закони щодо захисту особистих даних, такі, як GDPR, а саме стаття 32 «Безпека опрацювання», що каже про конфіденційність особистих даних та обмеження на їх поширення, підкреслюючи важливість застосування технічних та організаційних заходів для захисту даних, псевдонімізацію та шифрування для забезпечення конфіденційності, цілісності та доступності даних [3]. Через це з’являється потреба у підході, що буде відповідати законодавчим вимогам, оминаючи проблеми з ідентифікацією людини через профіль її тварини, що забезпечить як конфіденційність даних, так і ефективну роботу установ пет-френдлі.
     Основна мета курсової роботи – забезпечити зручний інтерфейс для власників тварин та установ для відвідування з домашніми улюбленцями для контролю за тваринами та надання їм якісного догляду, поліпшення сервісу та посилення рівню безпеки відповідно.
     Система забезпечить власників домашніх улюбленців можливістю стежити за показниками здоров’я тварини, її місцеперебуванням за допомогою спеціальних міток на ошийнику та мати доступ до переліку установ для потенційного відвідування з нею. Для власників закладів пет-френдлі вона стане компактною адміністративною панеллю для отримання інформації щодо профілів тварин-відвідувачів з метою надання відповідного сервісу домашнім улюбленцям та контролю за дотриманням заходів безпеки у закладі.
     
     
     1.2 Аналіз існуючих аналогів
     
     
     «PawPoint» – система, призначена для посилення заходів безпеки, покращення обслуговування в установах пет-френдлі та надання якісного догляду за домашніми улюбленцями шляхом створення надійного та ефективного середовища для власників тварин і персоналу відповідних установ. 
     Серед аналогів «PawPoint» можна виділити наступні програмні системи: Animal ID та JetVetPass, які також спрямовані на автоматизацію та полегшення процесів у догляді за тваринами.
     Animal ID – це система ідентифікації тварин, яка використовує мікрочіпи для надання унікального ідентифікатора кожній тварині. Перевагою системи є можливість ефективного встановлювання особистості власника та пошуку загублених тварин. Крім цього, мікрочіпи, що використовуються системою, мають тривалий термін служби, що гарантує надійну роботу системи протягом довгострокового періоду. Недоліком системи є неможливість відстеження місцеперебування тварини  та відсутність загальної інформації про тварину, яка могла б підвищити суму чайових відповідної пет-френдлі установи.
     Рішення зазначених проблем за допомогою «PawPoint»:
     – можливість не тільки ідентифікувати тварину, але й відстежувати її місцезнаходження та отримувати актуальні показники здоров’я;
     – дозволяє зберігати інформацію про уподобання та особливості кожної тварини, що допомагає персоналу закладу надавати індивідуальний догляд та тим самим поліпшувати користувацький досвід.
     JetVetPass – це цифрова медична платформа для тварин, яка надає власникам тварин доступ до медичної інформації про своїх улюбленців, а саме можливість перегляду історії хвороб та вакцинацій. Система є першим ветеринарним паспортом, що спрощує процес моніторингу здоров’я та догляду за тваринами, надаючи можливість мати необхідну документацію завжди під рукою. Серед переваг системи можна виділити відкритий доступ до документів тварин. Серед недоліків можна виділити наступні: вузька клієнтська база (лише ветеринарні клініки), не надає можливості отримувати актуальні показники здоров’я тварини.
     Рішення зазначених проблем за допомогою «PawPoint»:
     – зосереджується не лише на роботі ветеринарних установ, а ще й на адмініструванні інших закладів для відвідування з тваринами (салонів, ресторанів, спортивних залів тощо); 
     – сприяє безпеці не лише тварин, а й відвідувачів закладу шляхом контролю за наявністю необхідних медичних документів та щеплень, інформацією про тварину через автоматичне відправлення повідомлення адміністратору під час сканування мітки на ошийнику тварини.
     Монетизація програмного продукту, що створюється, полягатиме у наявності платної підписки на послуги для контролю за здоров’ям та місцезнаходженням тварин та отримання відсотку за розміщення установи для відвідування з тваринами в межах сервісу. Майбутнє розширення клієнтської бази, використання програми лояльності, участь у партнерських програмах з виробниками товарів для тварин та рекламні інтеграції з відомими блогерами також сприятимуть збільшенню доходів.


2 ПОСТАНОВКА ЗАДАЧІ
     2.1 Постановка бачення програмної системи
     
     
     Головне призначення програмної системи «PawPoint» – забезпечувати контроль над поточним місцезнаходженням тварини в реальному часі та її температурою тіла, сприяти покращенню рівню сервісу та безпеки в установах пет-френдлі. «PawPoint» слугуватиме утилітою для дотримання норм безпеки в громадських закладах, автоматично надаватиме інформацію про кожного з улюбленців-відвідувачів установи та заклади-партнери застосунку для отримання статистики за кількістю вакцинованих та щеплених тварин.
     Потужні зчитувачі миттєво скануватимуть мітки на ошийниках тварин та надсилатимуть адміністраторам PUSH-повідомлення з відповідною до налаштувань профілю господарем та типу установи інформацію про наявні щеплення, особливості породи та догляду для кожної зареєстрованої тварини, що сприятиме позитивному користувацькому досвіду та підвищенню безпеки в межах конкретного закладу. Крім цього, сервіс ставить на меті спрощення процесу нагляду за твариною, контролюючи її поточне перебування та надаючи актуальну статистику з показників температури тіла тварини за обраний проміжок часу.
     До того ж, у світі спостерігається посилення обмежень та відповідних заходів щодо доступу до особистої інформації та її поширення. Система «PawPoint» дозволить вирішити дану проблему шляхом ідентифікації людини за її домашнім улюбленцем. Особисті дані будуть зберігатись в зашифрованому вигляді.
     Розроблювана інформаційна система має бути масштабованою, відповідати вимогам сучасного ПЗ, бути побудованою на засадах чистої архітектури, чистого коду, принципів SOLID та використовуватиме шаблони проектування для написання слабко зв’язного коду.


     2.2 Основний функціонал системи
     
     
     Головний функціонал сервісу «PawPoint» поділяється на серверну, IoT-, Web- та Mobile-частини та включає:
     – управління закладами для відвідування з тваринами. Адміністратор зможе створювати заклад пет-френдлі, заповнювати актуальну інформацію щодо послуг для тварин, власноруч налаштовувати його та за потреби видаляти;
     – перегляд інформації по відвідувачах установи. Адміністратор зможе отримувати інформацію по наявних тварин-відвідувачів шляхом надсилання системою йому відповідного повідомлення при скануванні мітки на ошийнику тварини;
     – пошук, сортування та фільтрація наявних у системі установ пет-френдлі;
     – міні-магазин з одягом та їжею для домашніх улюбленців з можливістю бронювання та замовлення онлайн;
     – створення системи лояльності для користувачів зі знижками в закладах-партнерах. Користувач зможе накопичувати бонуси та отримувати подарунки;
     – рейтингова система закладу пет-френдлі. Користувач матиме змогу оцінювати відвідувану установу;
     – статистика по кількості вакцинованих тварин. Кожний заклад матиме можливість отримувати інформацію з вакцинації по кожній з тварин-відвідувачів для ведення звітності;
     – створення профілю домашніх улюбленців. Користувач зможе реєструвати кожну з тварин, заповнювати її особисту інформацію та обмежувати публічний доступ до конкретних даних тварини;
     – контроль над поточним місцеперебуванням домашньої тварини. Користувач зможе відстежувати місцезнаходження тварини на карті за допомогою відповідної мітки на ошийнику тварини;
     – контроль над показниками здоров’я домашнього улюбленця. Користувач матиме можливість отримувати статистику по температурі тіла тварини протягом дня;
     – ведення щоденнику здоров’я тварини. Користувач зможе вести облік медичних документів домашнього улюбленця, завантажувати інформацію про вакцинацію та/або щеплення;
     – відстеження тварини в реальному часі на карті. Користувач зможе переглядати місцезнаходження власного улюбленця та інших тварин сервісу на карті;
     – сигнал екстреного оповіщення. Користувач зможе подати сигнал SOS, який за потреби сповістить усіх користувачів сервісу про зникнення тварини;
     – улюблені заклади. Користувач зможе додавати заклади пет-френдлі, що сподобались в обране та робити нотатки;
     – історія відвіданих установ. Користувач матиме змогу переглядати історію відвідування по всім установам та по кожній установі окремо.
     Щодо захисту даних, можна виділити наступні пункти: 
     – усі паролі та медичні документи зберігатимуться в базі даних у закодованому вигляді: паролі від профілів кодуються за шифром Blowfish, медичні довідки шифруються за допомогою алгоритму AES; 
     – використання ORM Entity Framework Core для запобігання SQL ін’єкціям;
     – упроваджені аутентифікація і авторизація користувачів за токеном JWT з використанням симетричного ключа. Права доступу користувачів перевірятимуться перед доступом до конкретних ресурсів в залежності від ролі конкретного користувача.
     
     
     2.3 Рамки первинного випуску
     
     
     У рамках першого випуску планується реалізувати основну функціональність системи для догляду за тваринами та посилення заходів безпеки в установах для відвідування з домашніми улюбленцями шляхом автоматичного отримання адміністратором сповіщень з інформацією про тварину-відвідувача та її наявні медичні документи.
     Бізнес-логіка «PawPoint» ґрунтується на ряді операцій, що включають в себе функціонал для господарів домашніх улюбленців, власників установ пет-френдлі та адміністраторів системи.
     Функціонал серверної частини:
     – можливість реєструвати установу пет-френдлі в застосунку, власноруч налаштовувати її та за потреби видаляти для адміністратора системи;
     – можливість отримувати повідомлення з даними тварин-відвідувачів установи адміністратором у застосунку;
     – можливість створювати та заповнювати профілі домашніх тварин;
     – можливість створювати, редагувати та видаляти записи в щоденнику здоров’я тварини та завантажувати необхідні медичні документи;
     – робота з сесіями користувачів;
     – пошук, сортування, фільтрація пет-френдлі установ;
     – управління резервними копіями та сертифікатами;
     – збір аналітичних даних щодо показників здоров’я тварини для формування статистики шляхом взаємодії з розумними пристроями;
     – можливість ставити оцінку обраному закладу пет-френдлі;
     – можливість конфігурувати розумні пристрої через програмний інтерфейс адміністраторам установи.
     Web-функціонал:
     – можливість реєструвати установу пет-френдлі в застосунку, власноруч налаштовувати її та за потреби видаляти для адміністратора системи;
     – можливість створювати та заповнювати профілі домашніх тварин;
     – можливість створювати, редагувати та видаляти записи в щоденнику здоров’я тварини та завантажувати необхідні медичні документи;
     – пошук (за назвою), сортування (за рейтингом) та фільтрація (за категорією закладу) пет-френдлі установ;
     – можливість ставити оцінку обраному закладу пет-френдлі;
     – можливість конфігурувати розумні пристрої через програмний інтерфейс адміністраторам установи;
     – можливість управляти усіма користувачами системи системним адміністратором;
     Mobile-функціонал:
     – можливість отримувати повідомлення з даними тварин-відвідувачів установи адміністратором у застосунку;
     – можливість переглядати записи в щоденнику здоров’я тварини та завантажувати необхідні медичні документи;
     – можливість отримувати інформацію про поточне місцезнаходження домашньої тварини;
     – можливість моніторингу показників температури тварини протягом дня;
     – пошук, сортування, фільтрація пет-френдлі установ;
     – можливість ставити оцінку обраному закладу пет-френдлі.
     IoT:
     – надсилання PUSH-повідомлення адміністратору установи шляхом сканування мітки на ошийнику тварини;
     – отримання даних про актуальне місцеперебування тварини за допомогою трекеру GPS на ошийнику тварини;
     – отримання температурних показників тварини протягом дня за допомогою датчику температури, розташованому на ошийнику тварини.
     Для формування рейтингу пет-френдлі установи недостатньо лише середньої оцінки, тому буде використано розрахунок метрики популярності установи за допомогою зваженого рейтингу (формула 2.1). У цьому й полягає реалізація бізнес-логіки, за допомогою якої можна правильно оцінити певний заклад пет-френдлі. 


     Weighted Rating (WR) =(v/(v+m)⋅R)+ (m/(v+m)⋅C)                                    (2.1)
де v – кількість оцінок установи пет-френдлі; 
     m – мінімальна кількість оцінок у вибірці; 
     R – середній рейтинг конкретного заклад; 
     С – середнє значення рейтингу серед усіх закладів пет-френдлі.
     
     Щодо адміністрування у системі, сервіс матиме адміністративну панель для налаштування установ пет-френдлі з можливістю налаштувати пристрої для зчитування інформації про тварин.
     Також у сервісі для користувача буде запропоновано дві мови: українська та англійська. Локалізація буде реалізована шляхом застосування відповідних кодових таблиць символів та відображенні відповідного формату дати.
     Резервні копії створюватимуться за потребою системним адміністратором через клієнтський застосунок.
     
     
     2.4 Рамки наступних випусків
     
     
     Функціонал системи планується розширювати у подальшому. У майбутніх релізах сервісу можна буде виділити наступну функціональність:
     – інтеграція з наявними реєстрами ведення обліку тварин для автоматичного отримання інформації щодо проведених щеплень при реєстрації тварини;
     – інтеграція з брендами, що спеціалізуються на товарах для домашніх улюбленців. Користувач зможе зручно передивлятись товари для тварин в межах сервісу та створювати власну карту лояльності для отримання знижок у брендів-партнерів;
     – історія відвіданих закладів пет-френдлі;
     – відстеження місцезнаходження домашнього улюбленця в реальному часі на карті;
     – можливість подати сигнал екстреного оповіщення про зникнення тварини.
     
     
     2.5 Робоче середовище
     
     
     Серверна частина системи буде представлена ASP.NET Core Web API-застосунком, написаним на об’єктно орієнтованій мові програмування C# та з використанням платформи .NET 8. Авторизація буде виконана за допомогою JWT з використанням симетричного ключа, який буде зберігатись в налаштуваннях проекту. Доступ до ресурсів буде реалізовано за допомогою наявності різних ролей користувачів, відповідних атрибутів на кінцевих точках.
     Для зберігання даних та керування ними використовуватиметься СУБД MS SQL Server. Для зв’язку серверної частини з БД застосовуватиметься ORM Entity Framework Core.
     Frontend-частина буде реалізована за допомогою Angular 17 з використанням HTML, SCSS та мови програмування TypeScript. 
     Для Mobile-частини було обрано мову програмування Kotlin та Android IDE.
     IoT буде реалізовано за допомогою середовища розробки VS Code, фреймворку PlatformIO та мови програмування C++. Обмін даними клієнтів з серверною частиною буде відбуватися за допомогою мережевих протоколів HTTP/HTTPS.
     Крім цього, для реалізації основного функціоналу було обрано Google Map API для роботи з картами та місцезнаходженням тварини.
     Обраний технологічний стек забезпечить можливість легкого масштабування та підтримки проекту. Для забезпечення надійності системи передбачається застосування стратегій резервного копіювання даних.


3 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ
     3.1 Загальний огляд архітектури системи


     Для представлення фізичної форми програмної системи, що розробляється, було побудовано діаграму розгортання, що зображена на рисунку А.1 (див. Додаток А «Побудовані діаграми»).
     Можна побачити, що система складається з 4 основних компонентів: локальний сервер, мобільний пристрій, браузер та компонент Arduino С. У свою чергу, локальний сервер складається з серверної частини застосунку, клієнтської частини та компонента бази даних.
     Локальний сервер взаємодіє з компонентами C++ та мобільним пристроєм через порт 7114, а з браузером – з використанням порту 80.


     3.2 Проектування серверної частини системи


     Серверна частина системи буде представлена ASP.NET Core Web API-застосунком, написаним на об’єктно орієнтованій мові програмування C# та платформі .NET 8.
     Для розробки серверної частини програмної системи було обрано багатошарову архітектуру з поділом на наступні рівні: рівень моделей, рівень доступу до даних, рівень бізнес-логіки та рівень представлення. Цей тип архітектури було обрано через високий рівень абстрактності, яка допомагає підтримувати малу зв’язність та забезпечує легку розширюваність застосунку.
     За допомогою діаграми компонентів побудовано структурні компоненти серверної частини системи, зв’язки та залежності між ними (див. Додаток А «Побудовані діаграми» рис. А.2 та А.3). На діаграмі можна побачити, що контролери залежать від рівню бізнес-логіки, який, у свою чергу, залежить від рівня доступу до даних.
     З діаграми прецедентів системи «PawPoint» можна побачити можливості основних бізнес-користувачів системи – неавторизованого користувача, власника домашнього улюбленця, системного адміністратора та власника закладу пет-френдлі (див. Додаток А «Побудовані діаграми» рис. А.4).
     Системний адміністратор матиме доступ до клієнтської частини застосунку. У свою чергу, власник домашнього улюбленця та власник установи пет-френдлі матимуть доступ як до мобільної платформи системи, так і до її клієнтської частини.
     У розроблюваній системі завдання локалізації на стороні сервера полягатиме в правильній обробці дати та часу. Це буде досягатись шляхом реєстрації часу на сервері при обробці запитів на створення або оновлення даних. Система зберігатиме серверні дані в форматі UTC, щоб уникнути проблем з часовими зонами та переходами на літній та зимовий час. Під час виведення даних на стороні клієнта вони конвертуватимуться в належний формат дати та часу з урахуванням обраної локалізації. Система підтримуватиме дві локалізації: українську та англійську.
     Система використовуватиме JWT для автентифікації користувачів та визначення їхніх ролей. Після того, як користувач надсилатиме запит на авторизацію з логіном та паролем, сервер створюватиме токен доступу та токен оновлення. Ці токени надсилатимуться на веб-клієнт.


     3.3 Проектування IoT-частини системи


     IoT-частина буде реалізована за допомогою платформи Arduino, за допомогою фреймворку PlatformIO та мови програмування C++.
     На діаграмах взаємодії наведено детальний опис процесу обміну даними в межах системи (див. Додаток А «Побудовані діаграми» рис. А.5-А.7).
     На рисунку А.5 зображено процес обміну повідомленнями серверу з RFID-зчитувачем. Під час конфігурації зчитувача з сервера відправляється відповідна команда з даними для підключення до мережі Wi-Fi та посиланням для подальшої відправки відповіді на сервер, натомість на сервер повертається IP-адреса RFID-зчитувача. Процес конфігурації є однаковим для кожного з елементів IoT-частини. Під час активації RFID-зчитувача відбувається прив’язка до обраної установи, для власника якої буде автоматично створено повідомлення під час сканування мітки на ошийнику тварини-відвідувача.
     На рисунку А.6 зображено процес обміну повідомленнями серверу з датчиком температури. У залежності від надісланої на пристрій команди відбувається або зчитування температури, або розрахунок середнього показника температури за день, що буде надсилатись у якості відповіді на сервер.
     На рисунку А.7 зображено процес обміну повідомленнями серверу з GPS-трекером. Для отримання актуальних координат пристрій зв’язується з супутником та отримує від нього дані у вигляді широти та довготи, які потім надсилаються на сервер у якості відповіді.
     Для підключення до системи використовуватиметься модуль Wi-Fi, а процес взаємодії відбуватиметься за допомогою HTTP-запитів.
     Конфігурація пристроїв відбуватиметься через COM-порт, а їх спілкування з сервером – з використанням протоколу HTTPS у мережі Wi-Fi.
     Щодо архітектури, буде використано двошарову архітектуру з поділом на рівень моделей та рівень бізнес-логіки.
     Для реалізації функціоналу зчитування RFID-міток з ошийнику тварини буде задіяний Wi-Fi модуль NodeMCU V3 ESP8266 (CH340) та RFID-модуль RC522, а для реалізації розумного пристрою для отримання показників здоров’я тварини – Wi-Fi модуль NodeMCU V3 ESP8266 (CH340), датчик температури з аналоговим виходом NTC-10 та модуль GPS NEO-6M. Для спілкування з сервером буде створено та використано відповідний SSL-сертифікат.
     GPS-трекер встановлюватиме зв’язок із супутником та буде повертати поточні координати (широту та довготу) місцезнаходження домашнього улюбленця.
     Щодо ефективних математичних обчислень та акумуляції даних, можна виділити обрахунок середнього показника температури, який відбуватиметься на стороні розумного пристрою.
     Реалізація локалізації полягатиме у використанні відповідних кодових таблиць символів та відповідних до кожної з доступних локалізації одиниць виміру: для англійської локалізації для виміру температури тіла буде використано Фаренгейт, для української – Цельсій.
     Адмініструванням та конфігурацією IoT-пристроїв займатиметься системний адміністратор та власник установи (див. рис. А.8 у розділі Додаток А «Побудовані діаграми»). Системний адміністратор відповідатиме за налаштування розумного пристрою для виміру температури та визначення поточного місцезнаходження тварини. Власник установи конфігуруватиме зчитувач RFID. Адміністрування відбуватиметься з відповідної панелі адміністратора у веб-застосунку.
     
     
     3.4 Проектування клієнтської частини системи
     
     
     Клієнтська частина розроблюваної програмної системи представлятиме адміністративну панель для керування користувачами, установами пет-френдлі та профілями домашніх улюбленців.
     На діаграмі станів можна побачити поведінку окремо взятого об’єкту системи, чиї дії характеризуються реакцією на зовнішні чинники (див. Додаток А «Побудовані діаграми» рис. А.9-А.11).
     Кожен користувач без профілю може перейти на сторінку реєстрації та заповнити анкету. Після реєстрації йому буде запропоновано авторизуватися. 
     На рисунку А.9 зображено стани адміністрування системи. Після авторизації користувач з правами адміністратора може вибирати між управлінням користувачами (де він видає ролі) та управлінням тваринами (конфігурує пристрої для відстеження здоров’я та місцезнаходження тварин).
     На рисунку А.10 показано стани управління пет-френдлі установами. Власник установи може створювати, редагувати, видаляти установи, завантажувати логотип, управляти послугами та конфігурувати RFID-зчитувач для контролю тварин-відвідувачів.
     На рисунку А.11 зображено стани управління профілями домашніх улюбленців. Після авторизації власник тварин може створювати, редагувати, видаляти профілі тварин, управляти щоденником здоров’я (створювати, редагувати, видаляти записи), завантажувати документи та отримувати їх.
     Для написання клієнтської частини системи, що створюється, буде використаний фреймворк Angular, тому що він забезпечує зручну організацію коду за допомогою компонентної архітектури, а TypeScript, що використовується в якості мови програмування дозволяє підвищити читабельність коду [4] 
     За допомогою діаграми компонентів побудовано структурні компоненти клієнтської частини системи, зв’язки та залежності між ними (див. Додаток А «Побудовані діаграми» рис. А.12).
     Веб-браузер завантажуватиме на сторінку «app-root», що знаходиться в головному компоненті застосунку «AppComponent», а далі вже у цю кореневу сторінку буде завантажуватись наповнення відповідно до обраного url. 
     У файлі «app.routes.ts» визначатимуться маршрути для навігації в Angular застосунку. Кожен маршрут визначатиметься за допомогою шляху (URL) та відповідного компонента, який буде відображений при активації маршруту. 
     Файл «app.module.ts» є основним модулем Angular-застосунку, де визначатиметься конфігурація та загальна структура застосунку. 
     На діаграмі можна побачити основні компоненти системи: «registration», «diary-note-list», «user-list», «institutions», «pet-list», «facility-list», «login», які залежать від ряду сервісів.


     3.5 Проектування мобільного застосунку
     
     
     Мобільний застосунок – Android-застосунок, що буде розроблений за допомогою мови програмування Kotlin та середовища розробки Android Studio.
     На діаграмі діяльності можна побачити усі можливі дії, що будуть виконувати користувачі в межах системи (див. Додаток А «Побудовані діаграми» рис. А.13-А.14).
     Користувач без профілю буде переадресований на сторінку реєстрації. Після реєстрації йому пропонується авторизуватися. На рисунку 13 показано процес взаємодії адміністратора пет-френдлі закладу: після авторизації він потрапляє на сторінку з інформацією про тварин-відвідувачів, де можна переглядати дані та медичні документи тварин.
     На рисунку А.14 зображено процес взаємодії власника домашнього улюбленця: після авторизації він переходить на сторінку з переліком закладів, де можна фільтрувати, сортувати, оцінювати заклади, переглядати інформацію про них. Також є можливість перейти на сторінку управління профілями тварин, де можна переглядати профілі, управляти щоденниками здоров’я, отримувати інформацію про місцезнаходження та показники здоров’я улюбленців.
     Щодо архітектури застосунку, було обрано архітектуру MVC з чітким поділом на наступні шари: шар моделей, шар бізнес-логіки та шар відображення даних.
     За допомогою діаграми компонентів побудовано структурні компоненти мобільного застосунку системи (див. Додаток А «Побудовані діаграми» рис. А.15).
     Взаємодія мобільного застосунку з сервером здійснюватиметься за допомогою бібліотеки Retrofit. В «ApiService» будуть визначені всі необхідні кінцеві точки для комунікації з Web API. Web API, у свою чергу, звертатиметься до бази даних для отримання або збереження необхідної інформації.


4 СТРУКТУРА БАЗИ ДАНИХ


     З метою правильної розробки фізичної схеми бази даних першим чином необхідно обрати ті об’єкти, дані про які і будуть у подальшому зберігатися в ній.
     Серед них можна виділити наступні сутності: заклади для відвідування з тваринами («Institutions»), домашні тварини («Pets»), користувачі («Users»), профілі користувача («UserProfiles»), рейтинги закладів («Ratings»), записи показників здоров’я тварини («HealthRecords»), записи щоденника здоров’я тварини («DiaryNotes»), послуги установ («Facilities»), повідомлення («Notifications»), токени зміни паролю («ResetPasswordTokens») та токени оновлення («RefreshTokens»), налаштування RFID («RFIDSettings»), налаштування Arduino («ArduinoSettings»).
     Зв’язки між ними наведено нижче за допомогою ER-діаграми (див. Додаток А «Побудовані діаграми» рис. А.16). Серед них можна виділити:
     – установа пет-френдлі може мати 0 або багато оцінок, у свою чергу, оцінка відноситься лише до однієї установи (відношення «один-до-багатьох»);
     – установа пет-френдлі може мати 0 або багато послуг, у свою чергу, одна й та сама послуга може відноситись до 0 або багатьох установ (відношення «багато-до-багатьох»);
     – установа пет-френдлі має одне налаштування RFID, налаштування RFID відноситься лише до однієї установи (відношення «один-до-одного»);
     – домашній улюбленець може мати 0 або багато повідомлень, у свою чергу, повідомлення відноситься лише до 0 або однієї тварини (відношення «один-до-багатьох»);
     – домашній улюбленець може мати 0 або багато записів щоденника здоров’я, у свою чергу, запис щоденника відноситься лише до однієї тварини (відношення «один-до-багатьох»);
     – домашній улюбленець може мати 0 або багато записів показників здоров’я, у свою чергу, запис показника здоров’я відноситься лише до однієї тварини (відношення «один-до-багатьох»);
     – домашній улюбленець має одне налаштування Arduino водночас налаштування відноситься суто до однієї тварини (відношення «один-до-одного»);
     – користувач може мати 0 або багато домашніх улюбленців водночас домашній улюбленець належить одному користувачу (відношення «один-до-багатьох»); 
     – користувач може мати 0 або багато повідомлень водночас повідомлення належить одному користувачу (відношення «один-до-багатьох»);
     – користувач може мати 0 або багато закладів пет-френдлі водночас заклад пет-френдлі відноситься лише до одного користувача (відношення «один-до-багатьох»);
     – користувач може мати 0 або багато оцінок водночас оцінка відноситься лише до одного користувача (відношення «один-до-багатьох»);
     – користувач має один профіль, що відноситься лише до одного користувача (відношення «один-до-одного»);
     – користувач може мати 0 або багато токенів зміни паролю водночас токен відноситься лише до одного користувача (відношення «один-до-багатьох»);
     – користувач може мати 0 або багато токенів відновлення водночас токен відновлення відноситься лише до одного користувача (відношення «один-до-багатьох»).
     Щодо вибору бази даних, для цієї мети було використано СУБД MS SQL Server, тому що вона має підтримку обраного середовища розробки та забезпечує масштабованість.
     Для розроблюваної інформаційної системи оптимально підходить реляційна модель даних, що використовує таблиці для організації даних у вигляді об’єктів та відображає взаємозв’язки між ними за допомогою унікальних ідентифікаторів (первинних ключів).


5 КОДУВАННЯ ПРОГРАМНОЇ СИСТЕМИ
     5.1 Кодування серверної частини системи


     Для реалізації серверної частини застосунку була використана багатошарова архітектура з поділом на наступні рівні: Domain, DAL, BLL, WebAPI.
     У директорії «Config» зберігається config.json з налаштуваннями проекту.
     У директорії «Domain» розташовані два проекти: «Common» та «Domain». 
     У «Common» знаходяться моделі для налаштування авторизації, підключення до БД та SMTP-налаштування; статичні класи з константами валідації та регулярних виразів; користувацькі помилки; Перерахування; методи розширення; налаштування IoC-контейнеру. У «Domain» знаходяться моделі для бази даних.
     У директорії «DAL» розташовані проекти: «DAL» та «DAL.Startup». Даний шар архітектури слугує для забезпечення роботи з базою даних. Для взаємодії з моделями бази даних було обрано ORM Entity Framework Core.
     У «DAL.Startup» реєструються усі репозиторії разом з відповідними інтерфейсами та клас «UnitOfWork», що прописані в «DAL». Патерн «UnitOfWork» призначений для керування транзакціями та збереженням змін у базі даних. У конкретному випадку він об’єднує інтерфейси репозиторіїв в одному класі для зручної ін’єкції у сервіси [5].
     У директорії «BLL» знаходиться уся бізнес-логіка та проекти: «BLL» та «BLL.Startup».
     У проекті «BLL» зберігаються бізнес-сервіси для роботи з моделями, сервіс для роботи з SMTP та платіжні сервіси. Крім цього, в цій директорії знаходиться сервіс «InstitutionService» з реалізацією основної бізнес-логіки системи (див. Додаток В «Фрагменти програмного коду серверної частини системи»).
     У директорії «WebAPI» розташован і усі контролери, допоміжні моделі та проміжне програмне забезпечення застосунку. У цьому класі також розташований глобальний обробник помилок застосунку.
     Для ін’єкції залежностей використано шаблон проектування «Dependency Injection», що є реалізацією принципу «Inversion of Control» та слугує для побудови застосунку на абстракціях та забезпечення малої зв’язності між компонентами системи [6].
     Для реалізації локалізації було використано статичний клас «Resources», що містить методи для роботи з локалізованими ресурсами та відповідні файли з розширенням .rsx (див. Додаток В «Фрагменти програмного коду серверної частини системи»). Кожна частина системи має дві локалізації: англійську та українську.
     Для реалізації авторизації було створено власний «IdentityServer», що можна побачити в коді «AuthController» (див. Додаток В «Фрагменти програмного коду серверної частини системи»). У цьому контролері знаходяться кінцеві точки для авторизації та спеціальний метод для створення токену JWT.


     5.2 Кодування IoT-частини системи
     
     
     Для реалізації IoT було створено два окремих C++ застосунки з використанням IDE VS Code та розширення PlatformIO.
     Як і було згадано раніше, для реалізації IoT-частини було використано двошарову архітектуру. Структура проекту складається з двох основних директорій: «Domain» та «BLL».
     У директорії «Domain» зберігаються конфігурації, перерахування, моделі та відповіді для спілкування з сервером.
     Директорія «BLL» містить основну бізнес-логіку проекту, розташовану у файлах-заголовках та відповідних файлах з реалізацією. Серед них можна виділити сервіси для роботи з датчиком температури («TemperatureMonitorService») та зчитувачем RFID-міток («RFIDReaderService») (див. Додаток Г «Фрагменти програмного коду IoT-частини системи»). Також в цій директорії наявні допоміжні класи.
     Обидва застосунки мають файл main.cpp, який є головним файлом і слугує стартовою точкою для запуску програм на C++.
     Серед інженерних рішень можна виділити спілкування пристроїв з сервером, яке відбувається за участю спеціального протоколу, що створюються на сервері та оброблюються IoT-пристроєм у залежності від їх типу (див. Додаток Г «Фрагменти програмного коду IoT-частини системи»). У якості протоколу було створено базовий клас «CommandBase», що складається з властивості типу команди та обраної локалізації. Для роботи з IoT-пристроями можна виділити наступний ряд типів команд: «ConfigurePetDevice», «GetCurrentTemperature», «GetAverageTemperature», «GetCurrentLocation», «ConfigureRFIDReader». 
     Для реалізації бізнес-логіки з підрахунком середнього показника температури за день було створено клас «TemperatureMonitorService» із спеціальним масивом «temperatures». Дані, отримані пристроєм протягом дня з інтервалом у годину, зберігаються у цьому масиві, який оновлюється автоматично при зміні поточної дати.
     Щодо використаних під час розробки IoT-частини бібліотек, серед них можна виділити «ESP8266» та «NTC_TEMP_MODULE».
     
     
     5.3 Кодування клієнтської частини системи
     
     
     Клієнтська частина – це SPA-застосунок, написаний мовою TypeScript за допомогою фреймворку Angular.
     Щодо архітектури застосунку, можна виділити наступну структуру: директорії «core» та «components».
     У директорії «components» розміщено компоненти. У директорії «core» розташовані моделі, константи, сервіси та допоміжні класи.
     Щодо прийнятих інженерних рішень, був використаний шаблон проектування Dependency Injection для написання слабко зв’язного коду. Крім цього, для більш легкого спілкування з сервером було створено клас «ApiService» для обробки HTTP-запитів у застосунку Angular (див. Додаток Д «Фрагменти програмного коду клієнтської частини системи»).
     Для автоматизації обробки токенів використовується «JwtHelperService» з бібліотеки «angular-jwt». Бізнес-логіка для реалізації автентифікації знаходиться в «AuthService» та «HttpRequestInterceptor». Отримані токени з інформацією про поточного користувача зберігаються в LocalStorage. Необхідна для взаємодії з LocalStorage бізнес-логіка реалізована в «StorageService» (див. Додаток Д «Фрагменти програмного коду клієнтської частини системи»).
     Для реалізації локалізації та інтернаціоналізації в Angular використовуються бібліотеки «i18n» та «L10n». TranslationLoader використовується для завантаження перекладів з зовнішніх файлів у застосунок. L10nConfig визначає налаштування локалізації, такі як список доступних мов та шляхи до файлів перекладів. Файли JSON для кожної мови містять ключі та відповідні переклади для кожного текстового фрагменту.
     
     
     5.4 Кодування мобільного застосунку
     
     
     Мобільний застосунок програмної системи, що створюється, розроблений за допомогою мови програмування Kotlin та середовища розробки Android Studio.
     У якості архітектури було використано MVC.
     Можна виділити наступну структуру проекту: директорії «model», «network» та «ui».
     У директорії «model» знаходяться перерахування, моделі запитів та відповідей для роботи з Web API. У директорії «network» знаходяться інтерфейси та класи для взаємодії з сервером. У директорії «ui» знаходяться фрагменти сторінок та адаптери для відображення даних.
     Щодо прийнятих інженерних рішень, взаємодія мобільного застосунку з сервером здійснюється за допомогою бібліотеки Retrofit, бібліотеки для виконання HTTP-запитів, яка дозволяє відправляти та отримувати дані з сервера.
     Клас «ApiRepositoryImpl» відповідає за реалізацію інтерфейсу «ApiRepository», забезпечуючи взаємодію з «ApiService» через клієнт Retrofit. Також в «ApiRepositoryImpl» реалізовано логіку для реєстрації клієнту Retrofit (див. Додаток Е «Фрагменти програмного коду мобільного застосунку»).
     Для збереження JWT токена доступу використовується Intent. 
     Для реалізації локалізації в мобільному застосунку використовуються XML-файли з ресурсами, які автоматично завантажуються системою залежно від обраної локалізації. Для встановлення локалізації використовується метод «setLocale(languageCode)», який приймає код мови (наприклад, «en» для англійської або «uk» для української) і змінює поточну локалізацію застосунку (див. Додаток Е «Фрагменти програмного коду мобільного застосунку»). 
     Щодо маршрутизації, на основних сторінках застосунку розташовано компонент BottomNavigationView, який відповідає за навігацію між різними розділами застосунку.
     Стартова точка мобільного застосунку визначена у файлі «AndroidManifest.xml», у даному випадку це компонент activity сторінки авторизації «LoginPage». Можна виділити два основних компоненти activity «MainUserPage» та «MainAdminPage», у які під час експлуатації застосунку завантажуються необхідні фрагменти в залежності від обраної дії в BottomNavigationView.


6 ОПИС ПРОГРАМНОЇ РЕАЛІЗАЦІЇ
     6.1 Реалізація серверної частини системи


     Для запуску серверного застосунку необхідно встановити Microsoft Visual Studio 2022, платформу .NET 8 та ASP.NET Core SDK, відкрити файл «WebApi.exe», що знаходиться в директорії «PawPoint» проекту.
     Детальна специфікація кожного контролеру наведена у Додатку Б «REST-специфікація».


     6.2 Реалізація IoT-частини системи
     
     
     Як і було описано в підрозділі 3.3 розділу 3 «Проектування IoT-частини системи», взаємодія з розумним пристроєм здійснюється трьома бізнес-користувачами системи: системним адміністратором, власником домашнього улюбленця та власником установи пет-френдлі. 
     Конфігурація пристроїв здійснюється через веб-частину системи.
     Для налаштування розумного пристрою для отримання поточного місцезнаходження та показників температури тварини необхідно під’єднати відповідний модуль через COM-порт, авторизуватись як системний адміністратор перейти на сторінку «Домашні улюбленці», обрати будь-яку тварину та натиснути кнопку «Сконфігурувати». Після цього необхідно ввести дані WiFi-мережі: назву мережі та пароль від неї, а потім натиснути кнопку «Сконфігурувати розумний пристрій» (див. рис. 6.1). Після успішної конфігурації у полі «IP-адреса розумного пристрою» з’явиться відповідна адреса.
     

Рисунок 6.1 – Форма для конфігурації розумного пристрою в клієнтському застосунку
     
     Для того, щоб отримати поточне місцерозташування домашнього улюбленця та дані його температури, необхідно авторизуватись у мобільному застосунку як користувач з правами власника домашньої тварини, перейти на сторінку з домашніми улюбленцями, перейти на профіль будь-якого з них та натиснути на кнопки «Отримати поточну температуру» та «Отримати поточне місцезнаходження» відповідно (див. рис. 6.2).
     Для конфігурації RFID-зчитувача необхідно підключити модуль RFID через COM-порт, увійти в систему під користувачем з правами власника установи пет-френдлі, перейти на сторінку редагування обраної для налаштування установи у вкладку «Конфігурація RFID-зчитувача», заповнити поля з паролем, назвою WiFi-мережі. Після успішного налаштування установі буде надано відповідну IP-адресу зчитувача RFID.
     

Рисунок 6.2 – Отримання місцезнаходження та температури тіла тварини під час перегляду її профілю в мобільному застосунку

     Основна взаємодія з RFID-зчитувачем відбувається в мобільному застосунку. Для взаємодії з пристроєм необхідно авторизуватись як власник установи пет-френдлі та перейти на сторінку нотифікацій (див. рис. 6.3).
     

Рисунок 6.3 – Перегляд повідомлень з інформацією про тварину-відвідувача в мобільному застосунку, отриманих під час сканування мітки
     
     Під час сканування мітки на ошийнику тварини нове повідомлення з інформацією про домашнього улюбленця буде додано до списку.


     6.3 Реалізація клієнтської частини системи
     
     
     Взаємодію користувача з системою можна побачити на діаграмах станів (див. Додаток А «Побудовані діаграми» рис. А.9-А.11). Стани, між якими переходить кожен з користувачів системи, більш детально описані у підрозділі 3.4 «Проектування клієнтської частини системи» розділу 3 «Проектування програмної системи».
     Користувач, якщо не має профілю, буде переадресований на сторінку реєстрації. Після реєстрації йому пропонується авторизуватись (див. рис. 6.4).
     

Рисунок 6.4 – Форма авторизації клієнтської частини системи
     
     Користувача з правами системного адміністратора буде автоматично переадресовано на сторінку з наявними в системі користувачами після авторизації (див. рис. 6.5).
     

Рисунок 6.5 – Сторінка управління користувачами в веб-застосунку
     
     Для того, щоб зробити резервну копію бази даних, необхідно натиснути кнопку «Зробити резервну копію бази даних». Після успішного виконання операції необхідний файл з’явиться в директорії «DBBackups».
     Для видачі прав користувачам треба обрати користувача, натиснути кнопку «Редагувати роль» та обрати відповідні права (див. рис. 6.6).
     

Рисунок 6.6 – Модальне вікно для зміни прав користувача в веб-застосунку

     На сторінці «Домашні улюбленці» системний адміністратор може конфігурувати розумні пристрої для обраних тварин (більш детально розглянуто у підрозділі 6.2 «Реалізація IoT-частини системи»).
     Після успішної авторизації власника закладу пет-френдлі буде переадресовано на сторінку з усіма установами, прив’язаними до нього, де він зможе управляти ними шляхом створення нових закладів, редагування та видалення наявних (див. рис. 6.7).
  

Рисунок 6.7 – Сторінка для управління установами пет-френдлі в веб-застосунку
     
     Під час редагування установи користувачеві буде запропоновано завантажити логотип закладу та перейти на сторінку конфігурації RFID-зчитувача, прив’язаного до обраного закладу(більш детально розглянуто у підрозділі 6.2 «Реалізація IoT-частини системи») (див. рис.6.8).
     Крім цього, власнику установи під час редагування закладу буде запропоновано управління послугами в межах установи з можливістю додати нову у заклад або видалити наявну (див. рис.6.9).
     

Рисунок 6.8 – Сторінка редагування закладу пет-френдлі в веб-застосунку


Рисунок 6.9 – Управління послугами в межах установи пет-френдлі

     Після успішної авторизації власника домашнього улюбленця буде автоматично переадресовано на сторінку з наявними установами в межах системи, де він має можливість фільтрувати, сортувати установи з переліку (див. рис. 6.10).

Рисунок 6.10 – Сторінка для фільтрації, пошуку та сортування установ пет-френдлі у веб-застосунку
     
     Також власник тварини може переглянути інформацію про обрану установу та поставити їй оцінку.
     Крім цього, користувачеві надається можливість переходу на сторінку управління профілями домашніх улюбленців, де він має змогу створювати нові профілі, редагувати та видаляти вже наявні в системі профілі (див. рис. 6.11).
     

Рисунок 6.11 – Форма редагування тварини в веб-застосунку

     Під час редагування профілю домашнього улюбленця він має можливість управляти щоденником здоров’я тварини шляхом додавання та редагування записів щоденнику, завантаження та отримання відповідних медичних документів (див. рис. 6.12).
     

Рисунок 6.12 – Вікно редагування запису щоденника в веб-застосунку

     Кожна виконана дія супроводжується відповідним сповіщенням про успішне або неуспішне її виконання (див. рис. 6.13).
     

Рисунок 6.13 – Приклад сповіщення після успішного виконання операції в веб-застосунку
     
     Кожна з форм створення або редагування об’єктів системи перевіряє на відповідність вимогам введені дані та у разі введення некоректних даних виводить відповідне сповіщення (див. рис. 6.14). Перевірка користувацьких даних відбувається як на сервері на рівні DTO із застосуванням Data Annotations та перевірки з використанням ModelState, так і на клієнтській частині із застосовуванням відповідних атрибутів HTML.
     

Рисунок 6.14 – Приклад перевірки правильності введених даних в веб-застосунку
     
     Локалізація змінюється в межах навігаційної панелі (див. рис. 6.15).
     

Рисунок 6.15 – Список доступних мов для експлуатації в веб-застосунку

     Відповідно до обраної локалізації (української або англійської) буде змінено відображення тексту та формату дати.


     6.4 Реалізація мобільного застосунку системи
     
     
     Після успішної авторизації власника закладу для відвідування з тваринами буде переадресовано на сторінку з повідомленнями з інформацією про тварин-відвідувачів, де він зможе переглянути дані кожного домашнього улюбленця та відповідні медичні документи, що належать тварині (більш детально розглянуто в підрозділі 6.2 «Реалізація IoT-частини системи») (див. рис. 6.16).
     

Рисунок 6.16 – Приклад інформації про тварину, вказаної в повідомленні в мобільному застосунку
     
     Після успішної авторизації власник тварини потрапляє на сторінку з закладами пет-френдлі, де він може їх сортувати за зваженим рейтингом, фільтрувати за категорією та шукати заклад за назвою (розрахунок зваженого рейтингу більш детально описано в підрозділі 2.8 «Релізи» розділу 2 «Постановка задачі») (див. рис. 6.17).
     
іі
Рисунок 6.17– Сторінка установ пет-френдлі з фільтрацією в мобільному застосунку

     Кожну з наявних в списку установ можна переглянути. Крім того, її можна оцінити (див. рис. 6.18).
     Також власник домашнього улюбленця може перейти на сторінку з власними тваринами (див. рис. 6.19).
     На рисунку 6.20 можна побачити, як під час перегляду інформації про обраного улюбленця користувач може отримати лист показників здоров’я тварини, отримати дані про її поточне місцезнаходження та температуру тіла (отримання показників температури та місцеперебування тварини більш детально розглянуто в підрозділі 6.2 «Реалізація IoT-частини системи»).

Рисунок 6.18 – Перегляд інформації про установу в мобільному застосунку


Рисунок 6.19– Сторінка домашніх улюбленців в мобільному застосунку

Рисунок 6.20 – Перегляд профілю тварини в мобільному застосунку
     
     Під час редагування профілю як власник закладу пет-френдлі, так і власник тварини можуть змінити локалізацію системи (див. рис. 6.21).
     
а)б)
Рисунок 6.21 – Демонстрація локалізації в мобільному застосунку: а – англійська локалізація, б – українська


ВИСНОВКИ
     
     
     Під час виконання курсової роботи було розроблено програмну систему для контролю за місцезнаходженням і здоров’ям тварин та зручності відвідування закладів пет-френдлі «PawPoint», що забезпечує інтерфейс власникам тварин та пет-френдлі установам для контролю за показниками здоров’я та місцезнаходженням тварини, покращення заходів безпеки та надання високого сервісу в межах закладу відповідно. 
     У процесі розробки інформаційної системи було проаналізовано предметну область, на засадах якої було описано проектну специфікацію; визначено проблеми та потреби власників домашніх улюбленців та установ пет-френдлі, відповідні бізнес-можливості та бізнес-цілі; вивчено та застосовано на практиці принципи чистої архітектури та чистого коду, шаблони проектування.
     Крім того, під час виконання курсової роботи було досягнуто головну мету – отримання цінного досвіду з проектування складної інформаційної системи, побудованої з дотриманням архітектурних принципів, принципів SOLID та з застосуванням шаблонів проектування.
     Серверна частина системи – ASP.NET Core Web API застосунок з багатошаровою архітектурою, написаний на мові програмування C# з використанням ORM Entity Framework Core та СУБД MS SQL Server. Клієнтська частина написана з використанням фреймворку Angular 17. IoT-частина написана в PlatformIO на мові програмування C++. Мобільний застосунок написаний на Kotlin у середовищі розробки Android Studio.
     У результаті виконання курсової роботи було розроблено складну інформаційну систему для контролю за здоров’ям та місцезнаходженням домашніх тварин та покращення сервісу та рівню безпеки в установах пет-френдлі, що відповідає вимогам сучасного світу та задовольняє потреби потенційних користувачів.
     

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

     
     1. Роберт С. М. Чистий код. Створення і рефакторинг за допомогою Agile /Роберт С. М. – Харків: Фабула, 2019. – 448 с.
     2. Мартін Р. Книга Чиста архітектура: Мистецтво розроблення програмного забезпечення / пер. з англ. І. Бондар-Терещенко. Харків: Вид-во Фабула, 2021. – 368 с.
     3. Стаття 32 GDPR. Безпека опрацювання: https://gdpr-text.com/uk/read/article-32/ (Дата звернення 20.04.2024)
     4. Фрімен А. Angular для професіоналів. – Україна: Apress, 2020. – 800.
     5. Гамма Е., Хелм Р., Джонсон Р., Вліссідес Дж. Шаблони проектування: елементи багаторазового використання об'єктно-орієнтованого програмного забезпечення. – Денвер: Addison-Wesley,1994. – 395 с.
     6. Документація .NET dependency injection: https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection (Дата звернення 26.04.2024)


ДОДАТОК А
Побудовані діаграми


Рисунок А.1 – Діаграма розгортання для програмної системи «PawPoint»


Рисунок А.2 – Діаграма компонентів серверної частини програмної системи «PawPoint» (частина 1)


Рисунок А.3 – Діаграма компонентів серверної частини програмної системи «PawPoint» (Частина 2)

Рисунок А.4 – Загальна діаграма прецедентів програмної системи «PawPoint»


Рисунок А.5 – Діаграма взаємодії для роботи з RFID-зчитувачем


Рисунок А.6 – Діаграма взаємодії для роботи з датчиком температури


Рисунок А.7 – Діаграма взаємодії для роботи з GPS-трекером


Рисунок А.8 – Діаграма прецедентів IoT-частини програмної системи «PawPoint»


Рисунок А.9 – Діаграма станів IoT-частини для процесу адміністрування користувачами та даними системи «PawPoint»


Рисунок А.10 – Діаграма станів IoT-частини для процесу адміністрування установами пет-френдлі системи «PawPoint»


Рисунок А.11 – Діаграма станів IoT-частини для процесу управління профілями домашніх улюбленців системи «PawPoint»


Рисунок А.12 – Діаграма компонентів клієнтської частини системи «PawPoint»


Рисунок А.13 – Діаграма діяльності мобільного застосунку для користувача з правами власника установи пет-френдлі системи «PawPoint»


Рисунок А.14 – Діаграма діяльності мобільного застосунку для користувача з правами власника домашнього улюбленця системи «PawPoint»


Рисунок А.15 – Діаграма компонентів мобільної платформи системи «PawPoint»


Рисунок А.16 – ER-модель даних системи системи «PawPoint»


ДОДАТОК Б
REST-специфікація
     
     
     Таблиця 1 – Ендпоінти контролеру AuthController
Дія	Метод	Параметр	Відповіді
		Джерело	Назва	Тип	
login	POST	FromBody	login	string	Ok, Bad Request
			password		
get-user-by-refresh-token	GET	FromHeader	refreshTokenString	string	Ok, Bad Request


Таблиця 2 – Ендпоінти контролеру PetController
Дія	Метод	Параметр	                               Відповіді
		Джерело	        Назва	         Тип	
apply	POST	FromBody	petId	        Guid?	       Ok, Bad Request, Unauthorized, Forbidden
			        ownerId	        int	
			        nickName        string	
			        petType	        PetType	
			        birthDate       DateTime	
			        breed	        string	
			        weight	        double	
			        height	        double	
			        characteristics	string	
			        preferences     string	
			        illnesses       string	
			        rfid	        string	
get-all-by-owner-id GET	FromQuery ownerId	int	Ok, Bad Request, Unauthorized
get-pet-by-id	GET	FromQuery petId	        Guid	Ok, Bad Request, Unauthorized
delete	DELETE	FromQuery	petId	        Guid	Ok, Bad Request, Unauthorized,Forbidden

Таблиця 3 – Ендпоінти контролеру NotificationController
Дія	Метод	Параметр	Відповіді
		Джерело	Назва	Тип	
get-notifications-by-user-id	GET	FromQuery	userId	int	Ok, Bad Request, Forbidden, Unauthorized
get-notification-by-id	GET	FromQuery	notificationId	Guid	Ok, Bad Request, Forbidden, Unauthorized

Таблиця 4 – Ендпоінти контролеру UserController
Дія	Метод	Параметр	Відповіді
		Джерело	Назва	Тип	
request-reset-password	GET	FromQuery	token	string	Ok, Bad Request
forgot-password	POST	FromBody	email	string	Ok, Bad Request
register	POST	FromBody	login	string	Ok, Bad Request
			password	string	
			role	Role	
			region	Region	
			gender	Gender	
			email	string	
reset-password	POST	FromBody	token	string	Ok, Bad Request

			password	string	
			confirmPassword	string	
get-all	GET				Ok, Unauthorized, Forbidden
get-user-profile	GET	FromQuery	userId	int	Ok, Bad Request, Unauthorized
update-user-info	POST	FromBody	userId	int	Ok, Bad Request, Unauthorized

			email	string	
			gender	Gender	
			region	Region	
set-user-role	POST	FromBody	userId	int	Ok, Bad Request, Unauthorized, Forbidden
			role	Role	
do-db-backup	POST				Ok, Unauthorized, Forbidden

Таблиця 5 – Ендпоінти контролеру HealthRecordController
Дія	Метод	Параметр	Відповіді
		Джерело	Назва	Тип	
get-health-records	GET	FromQuery	petId	Guid	Ok, Bad Request, Unauthorized
			startDate	DateTime?	
			endDate	DateTime?	
get-health-record-statistics	GET	FromQuery	petId	Guid	Ok, Bad Request, Unauthorized, Forbidden
			endDate	DateTime?	
			startDate	DateTime?	

Таблиця 6 – Ендпоінти контролеру InstitutionController
Дія	Метод	Параметр	Відповіді
		Джерело	Назва	Тип	
apply	POST	FromBody	institutionId	int?	Ok, Bad Request, Unauthorized, Forbidden
			ownerId	int	
			description	string	
			name	string	
			latitude	double	
			longtitude	double	
			address	string	
			phoneNumber	string	
			institutionType	Institution-Type	
			webstiteUrl	string	
delete	DELETE	FromQuery	institutionId	int	Ok, Bad Request, UnauthorizedForbidden
set-rating	POST	FromBody	institutionId	int	Ok, Unauthorized, Bad Request
			userId	int	
			mark	int	
list	GET	FromQuery	searchQuery	string	Ok, Unauthorized Bad Request
			pageSize	int	
			pageCount	int	
			institutionType	Institution-Type?	
			sortByRatingAscending	bool	
get-institution-by-id	GET	FromQuery	institutionId	int	Ok, Bad Request, Unauthorized
upload-logo	POST	FromForm	institutionId	int	Ok, Bad Request, Unauthorized, Forbidden
			file	IFormFile	
get-by-owner-id	GET	FromQuery	ownerId	int	Ok, Bad Request, Unauthorized,Forbidden
add-facility-institution	POST	FromBody	institutionId	int	Ok, Bad Request, Unauthorized,Forbidden
			facilityId	int	
remove-facility-institution	POST	FromBody	institutionId	int	Ok, Bad Request, Unauthorized, Forbidden
			facilityId	int	

Таблиця 7 – Ендпоінти контролеру FacilityController
Дія	Метод	Параметр	Відповіді
		Джерело	Назва	Тип	
apply	POST	FromBody	facilityId	int?	Ok, Bad Request, Unauthorized, Forbidden
			name	string	
			description	string	
get-all-by-institution-id	GET	FromQuery	institutionId	int	Ok, Bad Request, Unauthorized, Forbidden
get-facility-by-id	GET	FromQuery	facilityId	int	Ok, Bad Request, Unauthorized, Forbidden
get-all					Ok, Unauthorized,Forbidden
delete	DELETE	FromQuery	facilityId	int	Ok, Bad Request, Unauthorized, Forbidden,

Таблиця 8 – Ендпоінти контролеру DiaryNoteController
Дія	Метод	Параметр	Відповіді
		Джерело	Назва	Тип	
apply	POST	FromBody	diaryNoteId	Guid?	Ok, Bad Request, Unauthorized, Forbidden
			petId	Guid	
			title	string	
			comment	string	
delete	DELETE	FromQuery	diaryNoteId	Guid	Ok, Bad Request, Unauthorized, Forbidden
get-all-for-pet	GET	FromQuery	petid	Guid	Ok, Unauthorized, Forbidden, Bad Request
download-document	GET	FromQuery	diaryNoteId	Guid	Ok, Unauthorized Bad Request
get-note-by-id	GET	FromQuery	diaryNoteId	Guid	Ok, Bad Request, Forbidden, Unauthorized
upload-document	POST	FromForm	diaryNoteId	Guid	Ok, Bad Request, Unauthorized, Forbidden


ДОДАТОК В
Фрагменти програмного коду серверної частини системи


     Код класу InstitutionService.cs:

1  using AutoMapper;
2  using BLL.Contracts;
3  using BLL.Infrastructure.Models.Institution;
4  using Common.Extensions;
5  using Common.Resources;
6  using DAL.Infrastructure.Models.Filters;
7  using DAL.UnitOfWork;
8  using Domain.Models;
9  
10  namespace BLL.Services;
11  
12  public record WeightedRatingGlobalCompounds(double AvgRatingForSet, int MinCountRatingForSet);
13  
14  public record WeightedRatingInstitutionCompounds(double AvgRatingForInstitution, int CountRatingForInstitution);
15  
16  public class InstitutionService : IInstitutionService
17  {
18      private readonly IUnitOfWork _unitOfWork;
19      private readonly Lazy<IMapper> _mapper;
20  
21      public InstitutionService(
22          IUnitOfWork unitOfWork,
23          Lazy<IMapper> mapper)
24      {
25          _unitOfWork = unitOfWork;
26          _mapper = mapper;
27      }
28  
29      public void Apply(CreateUpdateInstitutionModel institutionModel)
30      {
31          var institution = _mapper.Value.Map<Institution>(institutionModel);
32          _unitOfWork.Institutions.Value.Apply(institution);
33      }
34  
35      public void Delete(int institutionId)
36      {
37          _unitOfWork.Institutions.Value.Delete(institutionId);
38      }
39  
40      public IEnumerable<InstitutionListItem> GetAll(InstitutionFilter institutionFilter, int userId)
41      {
42          var institutions = _unitOfWork.Institutions.Value.GetAll(institutionFilter).ToList();
43          var institutionModels = MapInstitutionsToModels(institutions, userId);
44  
45          if (institutionFilter.SortByRatingAscending)
46              return institutionModels.OrderBy(i => i.Rating.Mark).ToList();
47          else
48              return institutionModels.OrderByDescending(i => i.Rating.Mark).ToList();
49      }
50  
51      public IEnumerable<InstitutionListItem> GetByOwnerId(int ownerId)
52      {
53          var institutions = _unitOfWork.Institutions.Value.GetAll().Where(i => i.OwnerId == ownerId).ToList();
54          return MapInstitutionsToModels(institutions, ownerId);
55      }
56  
57      public InstitutionModel GetById(int institutionId, int userId)
58      {
59          var institution = _unitOfWork.Institutions.Value.GetById(institutionId);
60          var institutionModel = _mapper.Value.Map<InstitutionModel>(institution);
61  
62          if (institutionModel.InstitutionId > 0)
63          {
64              var avgRating = institution.Ratings?.Any() == true ? institution.Ratings.Average(r => r.Mark) : 0;
65              institutionModel.Logo = GetLogoBase64(institution.LogoBytes);
66              institutionModel.Rating = new RatingModel
67              {
68                  InstitutionId = institutionId,
69                  Mark = avgRating,
70                  IsSetByCurrentUser = institution.Ratings.Any(r => r.UserId == userId)
71              };
72          }
73  
74          return institutionModel;
75      }
76  
77      public void SetRating(int institutionId, int userId, int mark)
78      {
79          _unitOfWork.Institutions.Value.SetRating(institutionId, userId, mark);
80      }
81  
82      public string UploadLogo(byte[] logoBytes, int institutionId)
83      {
84          _unitOfWork.Institutions.Value.UploadLogo(logoBytes, institutionId);
85          return Convert.ToBase64String(logoBytes);
86      }
87  
88      public void AddFacilityToInstitution(int facilityId, int institutionId)
89      {
90          _unitOfWork.Institutions.Value.AddFacilityToInstitution(facilityId, institutionId);
91      }
92  
93      public void RemoveFacilityFromInstitution(int facilityId, int institutionId)
94      {
95          _unitOfWork.Institutions.Value.RemoveFacilityFromInstitution(facilityId, institutionId);
96      }
97  
98      #region Helpers 
99  
100      private IEnumerable<InstitutionListItem> MapInstitutionsToModels(IEnumerable<Institution> institutions, int userId)
101      {
102          var institutionModels = new List<InstitutionListItem>();
103          var globalWeightedRatingCompounds = GetWeightedRatingCompounds(institutions);
104  
105          institutions.ToList().ForEach(i =>
106          {
107              var avgRating = i.Ratings?.Any() == true ? i.Ratings.Average(r => r.Mark) : 0;
108              var ratingCount = i.Ratings?.Count() ?? 0;
109  
110              var institutionModel = new InstitutionListItem
111              {
112                  InstitutionId = i.InstitutionId,
113                  Name = i.Name,
114                  InstitutionTypeName = Resources.Get(i.InstitutionType.ToString().ToUpper()),
115                  Rating = new RatingModel
116                  {
117                      InstitutionId = i.InstitutionId,
118                      Mark = avgRating,
119                      IsSetByCurrentUser = i.Ratings?.Any(r => r.UserId == userId) ?? false
120                  },
121                  Logo = GetLogoBase64(i.LogoBytes),
122                  RegionName = i.Region.GetEnumDescription()
123              };
124  
125              var institutionWeightedRatingCompounds = new WeightedRatingInstitutionCompounds(avgRating, ratingCount);
126              institutionModel.WeightedRating = GetWeightedRatingForInstitution(institutionWeightedRatingCompounds, globalWeightedRatingCompounds);
127  
128              institutionModels.Add(institutionModel);
129          });
130  
131  
132          return institutionModels;
133      }
134  
135      private WeightedRatingGlobalCompounds GetWeightedRatingCompounds(IEnumerable<Institution> institutions)
136      {
137          var avgRatingForSet = institutions?.Average(i => i.Ratings?.Any() == true ? i.Ratings.Average(r => r.Mark) : 0) ?? 0;
138          var minAmountForset = institutions?.Where(i => i.Ratings?.Count() > 0).Min(i => i.Ratings?.Count() ?? 0) ?? 0;
139  
140          return new WeightedRatingGlobalCompounds(avgRatingForSet, minAmountForset);
141      }
142  
143      private double GetWeightedRatingForInstitution(WeightedRatingInstitutionCompounds institutionCompounds, WeightedRatingGlobalCompounds globalCompounds)
144      {
145          double countRatingForInstitution = institutionCompounds.CountRatingForInstitution;
146          double avgRatingForInstitution = institutionCompounds.AvgRatingForInstitution;
147          double minCountRatingForSet = globalCompounds.MinCountRatingForSet;
148          double avgRatingForSet = globalCompounds.AvgRatingForSet;
149  
150          if (countRatingForInstitution == 0 && minCountRatingForSet == 0)
151              return default;
152  
153          double weightedRatingForInstitutionPart = (countRatingForInstitution * avgRatingForInstitution) / (countRatingForInstitution + minCountRatingForSet);
154          double weightedRatingForSetPart = (minCountRatingForSet * avgRatingForSet) / (countRatingForInstitution + minCountRatingForSet);
155  
156          return Math.Round(weightedRatingForInstitutionPart + weightedRatingForSetPart, 2);
157      }
158  
159      private string GetLogoBase64(byte[] logoBytes)
160      {
161          if (logoBytes != null && logoBytes.Any())
162              return Convert.ToBase64String(logoBytes);
163  
164          return null;
165      }
166  
167      #endregion
168  }



     Код класу Resources.cs:
     
1  using System.Resources;
2  
3  namespace Common.Resources;
4  public static class Resources
5  {
6      private static readonly Lazy<ResourceManager> ResourceManager = new Lazy<ResourceManager>(() =>
7      {
8          var resourceType = typeof(Resources);
9          return new ResourceManager(resourceType.FullName, resourceType.Assembly);
10      });
11  
12      public static string Get(string key)
13      {
14          var resourceValue = ResourceManager.Value.GetString(key);
15          return resourceValue ?? key;
16      }
17  }

     Код класу AuthController.cs
     
1  using BLL.Contracts;
2  using BLL.Infrastructure.Models.User;
3  using Common.Configs;
4  using Microsoft.AspNetCore.Mvc;
5  using Microsoft.IdentityModel.Tokens;
6  using System;
7  using System.Collections.Generic;
8  using System.IdentityModel.Tokens.Jwt;
9  using System.Security.Claims;
10  using WebAPI.Infrastructure.Extensions;
11  using WebAPI.Infrastructure.Models;
12  
13  namespace WebAPI.Controllers.IdentityServer;
14  [Area("auth")]
15  [Route("api/[area]")]
16  [ApiController]
17  public class AuthController : ControllerBase
18  {
19      private readonly AuthOptions _authOptions;
20      private readonly IUserService _userService;
21  
22      public AuthController(
23          AuthOptions authOptions,
24          IUserService userService)
25      {
26          _authOptions = authOptions;
27          _userService = userService;
28      }
29  
30      [HttpPost("login")]
31      public ActionResult Login([FromBody]LoginModel model)
32      {
33          if (!ModelState.IsValid)
34              return BadRequest(ModelState);
35  
36          var userId = _userService.LoginUser(model.Login, model.Password);
37          var token = GetToken(userId);
38  
39          return Ok(token);
40      }
41  
42      [HttpGet("get-user-by-refresh-token")]
43      public ActionResult GetUserByRefresh([FromHeader]string refreshTokenString)
44      {
45          var refreshToken = refreshTokenString.DecodeToken();
46          var user = _userService.GetUserByRefreshToken(refreshToken);
47          var token = GetToken(user);
48  
49          return Ok(token);
50      }
51  
52      #region Helpers
53  
54      private TokenModel GetToken(UserModel user)
55      {
56          var authParams = _authOptions;
57          var securityKey = authParams.SymmetricSecurityKey;
58          var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);
59          var userRole = user.Role.ToString();
60  
61          var jwtToken = new JwtSecurityToken(
62              authParams.Issuer,
63              authParams.Audience,
64              new List<Claim>() {
65                      new Claim("id", user.UserId.ToString()),
66                      new Claim(ClaimTypes.Role, userRole),
67                      new Claim("role", userRole),
68              },
69              expires: DateTime.Now.AddSeconds(authParams.TokenLifetime),
70              signingCredentials: credentials
71          );
72  
73          var tokenString = new JwtSecurityTokenHandler().WriteToken(jwtToken);
74          var token = new TokenModel()
75          {
76              AccessToken = tokenString,
77              RefreshToken = _userService.CreateRefreshToken(user.UserId).EncodeToken()
78          };
79  
80          return token;
81      }#endregion}

ДОДАТОК Г
Фрагменти програмного коду IoT-частини системи


     Код файлу TemperatureMonitorService.cpp:
     
1  #include "TemperatureMonitorService.h"
2  #include <BLL/Helpers/TemperatureHelper/TemperatureHelper.h>
3  #include <Domain/Models/Responses/ArduinoResponse.h>
4  
5  TemperatureMonitorService::TemperatureMonitorService() {
6      this->day = getTodaysDay();
7  }
8  
9  void TemperatureMonitorService::addTemperature(double temp) {
10      temperatures.push_back(temp);
11  }
12  
13  void TemperatureMonitorService::updateDay(int newDay) {
14      day = newDay;
15      temperatures.clear();
16  }
17  
18  int TemperatureMonitorService::getDay() const {
19      return day;
20  }
21  
22  vector<double>& TemperatureMonitorService::getTemperatures() {
23      return temperatures;
24  }
25  
26  String TemperatureMonitorService::getCurrentTemperature(String locale, NTC_TEMP_CLASS ntc) {
27      double currentTemperature = ntc.GetTemp();
28      if (locale == "en-US") {
29          currentTemperature = celsiusToFahrenheit(currentTemperature);
30      }
31  
32      ArduinoResponse response(
33          true,
34          "",
35          String(currentTemperature)
36      );
37  
38      return response.toJson();
39  }
40  
41  String TemperatureMonitorService::getAverageTemperature(String locale, NTC_TEMP_CLASS ntc) {
42      checkDate(ntc);
43      
44      double sum = 0;
45      for (double temperature : temperatures) {
46          sum += temperature;
47      }
48  
49      double average = sum / temperatures.size();
50      if (locale == "en-US") {
51          average = celsiusToFahrenheit(average);
52      }
53  
54      average = round(average * 100) / 100.0;
55  
56      ArduinoResponse response(
57          true,
58          "",
59          String(average)
60      );
61  
62      return response.toJson();
63  }
64  
65  int TemperatureMonitorService::getTodaysDay() {
66      auto now = chrono::system_clock::now();
67  
68      time_t now_time = chrono::system_clock::to_time_t(now);
69      tm* now_tm = localtime(&now_time);
70  
71      int day = now_tm->tm_mday;
72  
73      return day;
74  }
75  
76  void TemperatureMonitorService::checkDate(NTC_TEMP_CLASS ntc) {
77      int todaysDay = getTodaysDay();
78  
79      if (day != todaysDay) {
80          previousMillis = 0;
81          day = todaysDay;
82          addTemperature(ntc.GetTemp());
83      }
84  }
     
     Код файлу RFIDReaderService.cpp:
     
1  #include "RfidReaderService.h"
2  #include <ESP8266HTTPClient.h>
3  
4  RFIDReaderService::RFIDReaderService(MFRC522 &rfid, String callbackUrl, String userId)
5    : rfid(rfid), callbackUrl(callbackUrl), userId(userId) {}
6  
7  String RFIDReaderService::getDomainFromCallbackUrl() {
8      Serial.print("Hello from refidreader: ");
9      Serial.println(callbackUrl);
10      String ipAddress = "";
11      int colonIndex = callbackUrl.indexOf(':');
12      
13      if (colonIndex != -1) {
14          ipAddress = callbackUrl.substring(colonIndex + 3, callbackUrl.indexOf(':', colonIndex + 3));
15          Serial.print("IP address: ");
16          Serial.println(ipAddress);
17      } else {
18          Serial.println("Invalid URL format");
19      }
20  
21      return ipAddress;
22  }
23  
24  String RFIDReaderService::readRFID() {
25      if (!rfid.PICC_IsNewCardPresent()) {
26          return "";
27      }
28  
29      if (!rfid.PICC_ReadCardSerial()) {
30          return "";
31      }
32  
33      String tag = "";
34      for (int i = 0; i < rfid.uid.size; i++) {
35          tag += rfid.uid.uidByte[i];
36      }
37  
38      rfid.PICC_HaltA();
39      rfid.PCD_StopCrypto1();
40  
41      return tag;
42  }
43  
44  void RFIDReaderService::processTag() {
45      String tag = readRFID();
46      if (tag == "") {
47          return;
48      }
49  
50      WiFiClientSecure client;
51      String serverDomain = getDomainFromCallbackUrl();
52      client.setInsecure();
53  
54      if (client.connect(serverDomain, 7114)){
55          Serial.println("Connected to server");
56      } else {
57          Serial.println("ERROR connection to server");
58      }
59  
60      HTTPClient https;
61  
62      https.begin(client, callbackUrl);
63      https.addHeader("Content-Type", "application/json");
64  
65      Notification notification(userId.toInt(), tag);
66      String data = notification.toJson();
67  
68      int httpsResponseCode = https.POST(data);
69      Serial.print("HTTP status code = ");
70      Serial.println(httpsResponseCode);   
71  
72      https.end();
73  }
74  
75  void RFIDReaderService::setCallbackUrl(String newCallbackUrl) {
76      this->callbackUrl = newCallbackUrl;
77  }
78  
79  void RFIDReaderService::setUserId(int newUserId) {
80      this->userId = String(newUserId);
81  }


ДОДАТОК Д
Фрагменти програмного коду клієнтської частини системи
     
     
     Код класу ApiService.ts:
     
1  import { Injectable } from '@angular/core';
2  import { environment } from '../../../environments/environment.development';
3  import { HttpClient, HttpHeaders, HttpParams, HttpResponse } from '@angular/common/http';
4  import { Observable, OperatorFunction, tap } from 'rxjs';
5  
6  @Injectable({
7  	providedIn: 'root'
8  })
9  export class ApiService {
10  	private baseUrl = environment.webApi;
11  
12  	constructor(
13  		public http: HttpClient,
14  	) { }
15  
16  	public get<T>(
17  		url: string,
18  		options?: {
19  			headers?: HttpHeaders;
20  			params?: HttpParams;
21  		}
22  	) : Observable<HttpResponse<T>> {
23  		options ??= {};
24  		return this.http.get<HttpResponse<T>>(this.baseUrl + url, options);
25  	}
26  
27  	public download(
28  		url: string,
29  		options?: {
30  			headers?: HttpHeaders;
31  			params?: HttpParams;
32  		}
33  	) : Observable<Blob> {
34  		options ??= {};
35  		return this.http.get(this.baseUrl + url, { ...options, reportProgress: true, responseType: 'blob' });
36  	}
37  
38  	public post<T>(
39  		url: string,
40  		body?: any,
41  		options?: {
42  			headers?: HttpHeaders;
43  			params?: HttpParams;
44  		}
45  	): Observable<HttpResponse<T>> {
46  		options ??= {};
47  		return this.http.post<HttpResponse<T>>(this.baseUrl + url, body, options);
48  	}
49  
50  	public put<T>(
51  		url: string,
52  		body: any,
53  		options?: {
54  			headers?: HttpHeaders
55  		}
56  	): Observable<HttpResponse<T>> {
57  		options ??= {};
58  
59  		return this.http.put<HttpResponse<T>>(this.baseUrl + url, body, options);
60  	}
61  
62  	public delete<T>(
63  		url: string,
64  		options?: {
65  			headers?: HttpHeaders;
66  			params?: HttpParams;
67  			body?: any;
68  		}
69  	): Observable<HttpResponse<T>> {
70  		options ??= {};
71  
72  		return this.http.delete<HttpResponse<T>>(this.baseUrl + url, options);
73  	}
74  
75  	public login<T>(
76  		url: string,
77  		body?: any,
78  		options?: {
79  			headers?: HttpHeaders;
80  			params?: HttpParams;
81  		}
82  	): Observable<HttpResponse<T>> {
83  		options ??= {};
84  		return this.http.post<HttpResponse<T>>(url, body, options);
85  	}
86  
87  	public refresh<T>(
88  		url: string,
89  		options?: {
90  			headers?: HttpHeaders;
91  			params?: HttpParams;
92  		}
93  	): Observable<HttpResponse<T>> {
94  		options ??= {};
95  
96  		return this.http.get<HttpResponse<T>>(url, options);
97  	}
98  }
99  
100  export function extractData<T>(parseDate: boolean = false): OperatorFunction<any, any> {
101  	return (source: Observable<T>) =>
102  		source.pipe(tap(data => data));
103  }
104  
105  export function formatString(source: string, args: { [key: string]: string | number | boolean } | Array<string | number>): string {
106  	if (!source || source === '')
107  		return source;
108  
109  	return Array.isArray(args)
110  		? args.reduce((accumulator: string, value, index) => accumulator.replace(`{${index}}`, value?.toString()), source) as string
111  		: Object.entries(args).reduce((accumulator, [key, value]) => accumulator.replace(`{${key}}`, value?.toString()), source);
112  }
     
     Код класу StorageService.ts:
     
1  import { Injectable } from '@angular/core';
2  import { JwtHelperService } from '@auth0/angular-jwt';
3  import { Token } from '../models/auth/token';
4  
5  const USER_TOKEN = 'auth-user';
6  const USER_CULTURE = 'locale';
7  
8  @Injectable({
9  	providedIn: 'root'
10  })
11  export class StorageService {
12  
13  	constructor(
14  		private jwtHelper: JwtHelperService
15  	) { }
16  
17  	public clear(): void {
18  		window.sessionStorage.clear();
19  	}
20  
21  	public saveToken(data: Token): void {
22  		window.sessionStorage.removeItem(USER_TOKEN);
23  		window.sessionStorage.setItem(USER_TOKEN, JSON.stringify(data));
24  	}
25  
26  	public getToken(): Token {
27  		const data = window.sessionStorage.getItem(USER_TOKEN);
28  		if (data) {
29  			return JSON.parse(data) as Token;
30  		}
31  
32  		return {
33  			accessToken: "",
34  			refreshToken: ""
35  		} as Token;
36  	}
37  
38  	public isLoggedIn(): boolean {
39  		const user = window.sessionStorage.getItem(USER_TOKEN);
40  		if (user) {
41  			return true;
42  		}
43  
44  		return false;
45  	}
46  
47  	public isAdmin(): boolean {
48  		if (!this.isLoggedIn()){
49  			return false;
50  		}
51  
52  		const user = window.sessionStorage.getItem(USER_TOKEN);
53  		if (user == null) {
54  			return false;
55  		}
56  
57  		const token = JSON.parse(user)
58  		const accessToken = token['accessToken'];
59  		const decodedToken = this.jwtHelper.decodeToken(accessToken);
60  		decodedToken['role'];
61  
62  		return (decodedToken['role'] === 'Admin');
63  	}
64  
65  	public getUserRole(): string {
66  		if (!this.isLoggedIn()){
67  			return "";
68  		}
69  
70  		const user = window.sessionStorage.getItem(USER_TOKEN);
71  		if (user == null) {
72  			return "";
73  		}
74  
75  		const token = JSON.parse(user)
76  		const accessToken = token['accessToken'];
77  		const decodedToken = this.jwtHelper.decodeToken(accessToken);
78  		decodedToken['role'];
79  
80  		return decodedToken['role'];
81  	}
82  
83  	public getCurrentUserId(): number {
84  		const user = window.sessionStorage.getItem(USER_TOKEN);
85  		if (user == null) {
86  			return -1;
87  		}
88  
89  		const token = JSON.parse(user);
90  		const accessToken = token['accessToken'];
91  		const decodedToken = this.jwtHelper.decodeToken(accessToken);
92  
93  		return decodedToken['id'];
94  	}
95  
96  	public saveLocale(locale: string) {
97  		window.sessionStorage.removeItem(USER_CULTURE);
98  		window.sessionStorage.setItem(USER_CULTURE, locale);
99  	}
100  
101  	public getLocale() {
102  		const data = window.sessionStorage.getItem(USER_CULTURE);
103  		return data;
104  	}
105  }


ДОДАТОК Е
Фрагменти програмного коду мобільного застосунку


     Код класу ApiService.kt:
     
1  package com.pawpoint.network
2  
3  import com.pawpoint.model.request.DiaryNoteCreateRequest
4  import com.pawpoint.model.request.DiaryNoteRequest
5  import com.pawpoint.model.request.LoginRequest
6  import com.pawpoint.model.request.RatingRequest
7  import com.pawpoint.model.request.UpdateUserRequest
8  import com.pawpoint.model.request.UserRequest
9  import com.pawpoint.model.response.DiaryNoteDocumentModel
10  import com.pawpoint.model.response.DiaryNoteListItem
11  import com.pawpoint.model.response.DiaryNoteModel
12  import com.pawpoint.model.response.FacilityListItem
13  import com.pawpoint.model.response.GPSTrackerResponse
14  import com.pawpoint.model.response.HealthRecordModel
15  import com.pawpoint.model.response.InstitutionListItem
16  import com.pawpoint.model.response.InstitutionModel
17  import com.pawpoint.model.response.LoginResponse
18  import com.pawpoint.model.response.NotificationListItem
19  import com.pawpoint.model.response.NotificationModel
20  import com.pawpoint.model.response.PetListItem
21  import com.pawpoint.model.response.PetModel
22  import com.pawpoint.model.response.TemperatureMonitorResponse
23  import com.pawpoint.model.response.UserResponse
24  import retrofit2.Call
25  import retrofit2.http.Body
26  import retrofit2.http.GET
27  import retrofit2.http.Header
28  import retrofit2.http.Headers
29  import retrofit2.http.POST
30  import retrofit2.http.Query
31  import java.time.LocalDateTime
32  
33  interface ApiService {
34  
35      @Headers("Content-Type: application/json")
36      @POST("/api/auth/login")
37      fun login(@Body loginData: LoginRequest): Call<LoginResponse>
38  
39      @POST("/api/user/register")
40      fun register(@Body registrationData: UserRequest): Call<Void>
41  
42      @GET("/api/user/get-user-profile")
43      fun getUser(
44          @Header("Authorization") token: String,
45          @Query("userId") userId: Int
46      ): Call<UserResponse>
47  
48      @POST("/api/user/update-user-info")
49      @Headers("Content-Type: application/json")
50      fun updateUser(
51          @Header("Authorization") token: String,
52          @Body user: UpdateUserRequest
53      ): Call<Void>
54  
55      @GET("/api/pet/get-all-by-owner-id")
56      fun getPetsByOwnerId(
57          @Header("Authorization") token: String,
58          @Query("ownerId") ownerId: Int
59      ): Call<List<PetListItem>>
60  
61      @GET("/api/pet/get-pet-by-id")
62      fun getPetById(
63          @Header("Authorization") token: String,
64          @Query("petId") petId: String
65      ): Call<PetModel>
66  
67      @GET("/api/health-record/get-health-records")
68      fun getHealthRecords(
69          @Header("Authorization") token: String,
70          @Query("petId") petId: String,
71          @Query("startDate") startDate: LocalDateTime?,
72          @Query("endDate") endDate: LocalDateTime?
73      ): Call<List<HealthRecordModel>>
74  
75      @GET("/api/diary-note/get-all-for-pet")
76      fun getAllForPet(
77          @Header("Authorization") token: String,
78          @Query("petId") petId: String
79      ): Call<List<DiaryNoteListItem>>
80  
81      @GET("/api/diary-note/get-note-by-id")
82      fun getNoteById(
83          @Header("Authorization") token: String,
84          @Query("diaryNoteId") diaryNoteId: String
85      ): Call<DiaryNoteModel>
86  
87      @POST("/api/diary-note/apply")
88      @Headers("Content-Type: application/json")
89      fun createNote(
90          @Header("Authorization") token: String,
91          @Body diaryNoteRequest: DiaryNoteCreateRequest
92      ): Call<Void>
93  
94      @POST("/api/diary-note/upload-document")
95      @Headers("Content-Type: application/json")
96      fun uploadDocument(
97          @Header("Authorization") token: String,
98          @Body diaryNoteRequest: DiaryNoteRequest
99      ): Call<Void>
100  
101      @GET("/api/diary-note/download-document")
102      fun downloadDocument(
103          @Header("Authorization") token: String,
104          @Query("diaryNoteId") diaryNoteId: String
105      ): Call<DiaryNoteDocumentModel>
106  
107      @GET("/api/notification/get-notifications-by-user-id")
108      fun getNotificationsByUserId(
109          @Header("Authorization") token: String,
110          @Query("userId") userId: Int
111      ): Call<List<NotificationListItem>>
112  
113      @GET("/api/notification/get-notification-by-id")
114      fun getNotificationById(
115          @Header("Authorization") token: String,
116          @Query("notificationId") notificationId: String
117      ): Call<NotificationModel>
118  
119      @GET("/api/institution/list")
120      fun getInstitutionList(
121          @Header("Authorization") token: String,
122          @Query("searchQuery") searchQuery: String?,
123          @Query("type") type: Int?,
124          @Query("sortByRatingAscending") sortByRatingAscending: Boolean?
125      ): Call<List<InstitutionListItem>>
126  
127      @GET("/api/institution/get-institution-by-id")
128      fun getInstitutionById(
129          @Header("Authorization") token: String,
130          @Query("institutionId") institutionId: Int
131      ): Call<InstitutionModel>
132  
133      @POST("/api/institution/set-rating")
134      @Headers("Content-Type: application/json")
135      fun setRating(
136          @Header("Authorization") token: String,
137          @Body ratingRequest: RatingRequest
138      ): Call<Void>
139  
140      @GET("/api/facility/get-all-by-institution-id")
141      fun getAllFacilitiesByInstitutionId(
142          @Header("Authorization") token: String,
143          @Query("institutionId") institutionId: Int
144      ): Call<List<FacilityListItem>>
145  
146      @GET("/api/Arduino/get-pet-temperature-data")
147      fun getCurrentPetTemp(
148          @Header("Authorization") token: String,
149          @Query("petId") petId: String
150      ): Call<Double>
151  
152      @GET("/api/Arduino/get-pet-location-data")
153      fun getCurrentPetLocation(
154          @Header("Authorization") token: String,
155          @Query("petId") petId: String
156      ): Call<GPSTrackerResponse>
157  }
     
     
     Код класу ApiRepositoryImpl.kt:
     
1  package com.pawpoint.network
2  
3  import com.pawpoint.model.request.DiaryNoteCreateRequest
4  import com.pawpoint.model.request.DiaryNoteRequest
5  import com.pawpoint.model.request.LoginRequest
6  import com.pawpoint.model.request.RatingRequest
7  import com.pawpoint.model.request.UpdateUserRequest
8  import com.pawpoint.model.request.UserRequest
9  import com.pawpoint.model.response.DiaryNoteDocumentModel
10  import com.pawpoint.model.response.DiaryNoteListItem
11  import com.pawpoint.model.response.DiaryNoteModel
12  import com.pawpoint.model.response.FacilityListItem
13  import com.pawpoint.model.response.GPSTrackerResponse
14  import com.pawpoint.model.response.HealthRecordModel
15  import com.pawpoint.model.response.InstitutionListItem
16  import com.pawpoint.model.response.InstitutionModel
17  import com.pawpoint.model.response.LoginResponse
18  import com.pawpoint.model.response.NotificationListItem
19  import com.pawpoint.model.response.NotificationModel
20  import com.pawpoint.model.response.PetListItem
21  import com.pawpoint.model.response.PetModel
22  import com.pawpoint.model.response.TemperatureMonitorResponse
23  import com.pawpoint.model.response.UserResponse
24  import okhttp3.OkHttpClient
25  import retrofit2.Callback
26  import retrofit2.Retrofit
27  import retrofit2.converter.gson.GsonConverterFactory
28  import java.time.LocalDateTime
29  
30  class ApiRepositoryImpl : ApiRepository {
31  
32      private val client = OkHttpClient.Builder().build()
33  
34      private val retrofit = Retrofit.Builder()
35          .baseUrl("https://7f50-91-142-173-12.ngrok-free.app")
36          .addConverterFactory(GsonConverterFactory.create())
37          .client(client)
38          .build()
39  
40      private val service = retrofit.create(ApiService::class.java)
41  
42      override fun login(user: LoginRequest, callback: Callback<LoginResponse>) {
43          service.login(user).enqueue(callback)
44      }
45  
46      override fun register(user: UserRequest, callback: Callback<Void>) {
47          service.register(user).enqueue(callback)
48      }
49  
50      override fun getUser(token: String, userId: Int, callback: Callback<UserResponse>) {
51          service.getUser(token, userId).enqueue(callback)
52      }
53  
54      override fun updateUser(token: String, user: UpdateUserRequest, callback: Callback<Void>) {
55          service.updateUser(token, user).enqueue(callback)
56      }
57  
58      override fun getPetsByOwnerId(
59          token: String, ownerId: Int,
60          callback: Callback<List<PetListItem>>
61      ) {
62          service.getPetsByOwnerId(token, ownerId).enqueue(callback)
63      }
64  
65      override fun getPetById(token: String, petId: String, callback: Callback<PetModel>) {
66          service.getPetById(token, petId).enqueue(callback)
67      }
68  
69      override fun getHealthRecords(
70          token: String,
71          petId: String,
72          startDate: LocalDateTime?,
73          endDate: LocalDateTime,
74          callback: Callback<List<HealthRecordModel>>
75      ) {
76          service.getHealthRecords(token, petId, startDate, endDate).enqueue(callback)
77      }
78  
79      override fun getAllForPet(
80          token: String,
81          petId: String,
82          callback: Callback<List<DiaryNoteListItem>>
83      ) {
84          service.getAllForPet(token, petId).enqueue(callback)
85      }
86  
87      override fun getNoteById(
88          token: String,
89          diaryNoteId: String,
90          callback: Callback<DiaryNoteModel>
91      ) {
92          service.getNoteById(token, diaryNoteId).enqueue(callback)
93      }
94  
95      override fun createNote(
96          token: String,
97          diaryNoteRequest: DiaryNoteCreateRequest,
98          callback: Callback<Void>
99      ) {
100          service.createNote(token, diaryNoteRequest).enqueue(callback)
101      }
102  
103      override fun uploadDocument(
104          token: String,
105          diaryNoteRequest: DiaryNoteRequest,
106          callback: Callback<Void>
107      ) {
108          service.uploadDocument(token, diaryNoteRequest).enqueue(callback)
109      }
110  
111      override fun downloadDocument(
112          token: String,
113          diaryNoteId: String,
114          callback: Callback<DiaryNoteDocumentModel>
115      ) {
116          service.downloadDocument(token, diaryNoteId).enqueue(callback)
117      }
118  
119      override fun getNotificationsByUserId(
120          token: String,
121          userId: Int,
122          callback: Callback<List<NotificationListItem>>
123      ) {
124          service.getNotificationsByUserId(token, userId).enqueue(callback)
125      }
126  
127      override fun getNotificationById(
128          token: String,
129          notificationId: String,
130          callback: Callback<NotificationModel>
131      ) {
132          service.getNotificationById(token, notificationId).enqueue(callback)
133      }
134  
135      override fun getInstitutionList(
136          token: String,
137          searchQuery: String?,
138          type: Int?,
139          sortByRatingAscending: Boolean,
140          callback: Callback<List<InstitutionListItem>>
141      ) {
142          service.getInstitutionList(token, searchQuery, type, sortByRatingAscending)
143              .enqueue(callback)
144      }
145  
146      override fun getInstitutionById(
147          token: String,
148          institutionId: Int,
149          callback: Callback<InstitutionModel>
150      ) {
151          service.getInstitutionById(token, institutionId).enqueue(callback)
152      }
153  
154      override fun setRating(token: String, ratingRequest: RatingRequest, callback: Callback<Void>) {
155          service.setRating(token, ratingRequest).enqueue(callback)
156      }
157  
158      override fun getAllFacilitiesByInstitutionId(
159          token: String,
160          institutionId: Int,
161          callback: Callback<List<FacilityListItem>>
162      ) {
163          service.getAllFacilitiesByInstitutionId(token, institutionId).enqueue(callback)
164      }
165  
166      override fun getCurrentPetTemp(
167          token: String,
168          petId: String,
169          callback: Callback<Double>
170      ) {
171          service.getCurrentPetTemp(token, petId).enqueue(callback)
172      }
173  
174      override fun getCurrentPetLocation(
175          token: String,
176          petId: String,
177          callback: Callback<GPSTrackerResponse>
178      ) {
179          service.getCurrentPetLocation(token, petId).enqueue(callback)
180      }
181  }
     
     Код ProfileUserPage.kt:
     
1  package com.pawpoint.ui.activity
2  
3  import android.content.Intent
4  import android.content.res.Configuration
5  import android.os.Bundle
6  import android.util.Log
7  import android.view.LayoutInflater
8  import android.view.View
9  import android.view.ViewGroup
10  import android.widget.ImageButton
11  import android.widget.TextView
12  import android.widget.Toast
13  import androidx.fragment.app.Fragment
14  import com.pawpoint.R
15  import com.pawpoint.model.перерахування.Region
16  import com.pawpoint.model.response.UserResponse
17  import com.pawpoint.network.ApiRepositoryImpl
18  import retrofit2.Call
19  import retrofit2.Callback
20  import retrofit2.Response
21  import java.util.Locale
22  
23  
24  class ProfileUserPage : Fragment() {
25  
26      private val activity: Fragment = this@ProfileUserPage
27      private val apiRepository = ApiRepositoryImpl()
28      private lateinit var token: String
29      private lateinit var userId: String
30      private lateinit var username: TextView
31      private lateinit var email: TextView
32      private lateinit var region: TextView
33      private lateinit var signout: TextView
34      private lateinit var language: TextView
35      private lateinit var lang: String
36      private lateinit var editButton: ImageButton
37  
38      override fun onCreate(savedInstanceState: Bundle?) {
39          super.onCreate(savedInstanceState)
40          arguments?.let {
41          }
42      }
43  
44      override fun onCreateView(
45          inflater: LayoutInflater, container: ViewGroup?,
46          savedInstanceState: Bundle?
47      ): View {
48          val v: View = inflater.inflate(R.layout.activity_profile_user_page, container, false)
49          init(v)
50          return v
51      }
52  
53      private fun init(v: View) {
54          if (MainUserPage.getUserId() == null) {
55              userId = MainAdminPage.getUserId().toString()
56              token = MainAdminPage.getToken().toString()
57          } else {
58              userId = MainUserPage.getUserId().toString()
59              token = MainUserPage.getToken().toString()
60          }
61  
62          username = v.findViewById(R.id.loginText)
63          email = v.findViewById(R.id.emailText)
64          region = v.findViewById(R.id.regionText)
65          language = v.findViewById(R.id.language)
66          editButton = v.findViewById(R.id.editUserButton)
67  
68          if (Locale.getDefault().language == "en") {
69              lang = "uk"
70              language.text = getString(R.string.msg11)
71          } else {
72              lang = "en"
73              language.text = getString(R.string.msg112)
74          }
75  
76          signout = v.findViewById(R.id.singOut)
77  
78          signout.let { s ->
79              s.setOnClickListener {
80                  logout()
81              }
82          }
83  
84          language.let { s ->
85              s.setOnClickListener {
86                  setLocale(lang)
87                  if (lang == "en") {
88                      lang = "uk"
89                  } else {
90                      lang = "en"
91                  }
92              }
93          }
94  
95          editButton.let { s ->
96              s.setOnClickListener {
97                  val intent = Intent(activity.context, UpdateUser::class.java)
98                  startActivity(intent)
99              }
100          }
101  
102          getUser()
103      }
104  
105      private fun getUser() {
106          apiRepository.getUser("Bearer " + token, userId.toInt(), object :
107              Callback<UserResponse> {
108              override fun onResponse(
109                  call: Call<UserResponse>,
110                  response: Response<UserResponse>
111              ) {
112                  if (response.isSuccessful) {
113                      val user = response.body()
114  
115                      if (user != null) {
116                          fillData(user)
117                      } else {
118                          Toast.makeText(getActivity(), "Something went wrong!", Toast.LENGTH_LONG)
119                              .show()
120                      }
121                  } else {
122                      Toast.makeText(
123                          getActivity(),
124                          "Something went wrong!"
125                                  + "Response " + response.code() + " " + response.message(),
126                          Toast.LENGTH_LONG
127                      )
128                          .show()
129                  }
130              }
131  
132              override fun onFailure(call: Call<UserResponse>, t: Throwable) {
133                  Toast.makeText(getActivity(), "Something went wrong!", Toast.LENGTH_LONG).show()
134              }
135          })
136      }
137  
138      fun fillData(user: UserResponse) {
139          val usernameText = user.login
140          val emailText = user.email
141          val regionText = getRegion(user.region)
142  
143          username.text = username.text.toString() + ": $usernameText"
144          email.text = email.text.toString() + ": $emailText"
145          region.text = region.text.toString() + ": $regionText"
146      }
147  
148      private fun getRegion(region: Int): String {
149          return Region.entries[region - 1].name
150              .replace("__", "-")
151              .replace("_", " ")
152      }
153  
154      fun logout() {
155          val intent = Intent(activity.context, LoginPage::class.java)
156          startActivity(intent)
157          activity.requireParentFragment().requireActivity().finish()
158      }
159  
160      private fun setLocale(languageCode: String) {
161          val locale = Locale(languageCode)
162          Locale.setDefault(locale)
163          val resources = activity.resources
164          val config: Configuration = resources.configuration
165          config.setLocale(locale)
166          resources.updateConfiguration(config, resources.displayMetrics)
167      }
168  }


ДОДАТОК Ж
Результат перевірки на відсоток плагіату


Рисунок Ж.1 – Результат перевірки на відсоток плагіату
